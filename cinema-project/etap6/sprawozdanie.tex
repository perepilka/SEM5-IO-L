\documentclass[12pt,a4paper]{article}

% Pakiety
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{hyperref}

% Konfiguracja strony
\geometry{
    a4paper,
    left=2.5cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

% Konfiguracja listings dla Javy
\definecolor{javared}{rgb}{0.6,0,0}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\definecolor{javapurple}{rgb}{0.5,0,0.35}
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75}

\lstset{
    language=Java,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{javapurple}\bfseries,
    stringstyle=\color{javared},
    commentstyle=\color{javagreen},
    morecomment=[s][\color{javadocblue}]{/**}{*/},
    numbers=left,
    numberstyle=\tiny\color{black},
    stepnumber=1,
    numbersep=10pt,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    breaklines=true,
    breakatwhitespace=true,
    frame=single,
    captionpos=b,
    literate={ą}{{\k{a}}}1 {ć}{{\'c}}1 {ę}{{\k{e}}}1 {ł}{{\l{}}}1 {ń}{{\'n}}1 {ó}{{\'o}}1 {ś}{{\'s}}1 {ź}{{\'z}}1 {ż}{{\.z}}1 {Ą}{{\k{A}}}1 {Ć}{{\'C}}1 {Ę}{{\k{E}}}1 {Ł}{{\L{}}}1 {Ń}{{\'N}}1 {Ó}{{\'O}}1 {Ś}{{\'S}}1 {Ź}{{\'Z}}1 {Ż}{{\.Z}}1,
}

\title{Sprawozdanie z Etapu 6: Testowanie Jednostkowe}
\author{Oleksandr Radionenko (274003), Yaroslav Perepilka (282279)}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Wstęp}

Niniejsze sprawozdanie zawiera kod testów jednostkowych oraz zestawów testów zorganizowany według zadań i przypadków użycia.


\section{Zadanie 1: Testy jednostkowe bez mockowania}

\subsection{Przypadek użycia: Dodanie filmu do oferty}

W tym zadaniu testujemy klasy bez symulacji zależności (bez mockowania).

\subsubsection{model.TestFilm}
Plik: \texttt{src/test/java/model/TestFilm.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy Film.
 * Testuje encję danych filmu - podstawową strukturę przechowującą informacje o
 * filmie.
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Warstwa: Encja (model)
 * Zadanie: 1 (testy bez mockowania)
 */
@DisplayName("Testy klasy Film - encja danych")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("dodawanie")
class TestFilm {

    // Dane testowe przygotowywane przed każdym testem
    private Film film;
    private static final String TEST_ID = "F001";
    private static final String TEST_TYTUL = "Matrix";
    private static final String TEST_OPIS = "Cyberpunk thriller";
    private static final int TEST_CZAS = 136;
    private static final String TEST_GATUNEK = "SciFi";
    private static final double TEST_CENA = 28.5;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów klasy Film");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Przygotowanie danych testowych przed każdym testem
        // Tworzymy nowy obiekt Film z określonymi danymi
        film = new Film(TEST_ID, TEST_TYTUL, TEST_OPIS, TEST_CZAS, TEST_GATUNEK, TEST_CENA);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        film = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów klasy Film");
    }

    // ========== TESTY KONSTRUKTORA ==========

    @Test
    @Order(1)
    @DisplayName("Test tworzenia filmu przez konstruktor")
    void testTworzenieFilmu() {
        // Jeśli: Dane do utworzenia filmu zostały przygotowane w setUp()

        // Gdy: Film został utworzony w setUp()

        // Wtedy: Obiekt filmu nie powinien być null i powinien mieć poprawne dane
        assertNotNull(film, "Film nie powinien być null po utworzeniu");
        assertInstanceOf(Film.class, film, "Obiekt powinien być instancją klasy Film");
        assertTrue(film instanceof IFilm, "Film powinien implementować interfejs IFilm");
    }

    // ========== TESTY GETTERÓW ==========

    @Test
    @Order(2)
    @DisplayName("Test metody dajId() - zwracanie identyfikatora")
    void testDajId() {
        // Jeśli: Film został utworzony z ID = "F001"

        // Gdy: Pobieramy ID filmu
        String id = film.dajId();

        // Wtedy: ID powinno być równe wartości podanej w konstruktorze
        assertNotNull(id, "ID nie powinno być null");
        assertEquals(TEST_ID, id, "ID powinno być równe 'F001'");
        assertTrue(id.startsWith("F"), "ID powinno zaczynać się od 'F'");
    }

    @Test
    @Order(3)
    @DisplayName("Test metody dajTytul() - zwracanie tytułu")
    void testDajTytul() {
        // Jeśli: Film został utworzony z tytułem "Matrix"

        // Gdy: Pobieramy tytuł filmu
        String tytul = film.dajTytul();

        // Wtedy: Tytuł powinien być równy wartości podanej w konstruktorze
        assertNotNull(tytul, "Tytuł nie powinien być null");
        assertEquals(TEST_TYTUL, tytul, "Tytuł powinien być równy 'Matrix'");
        assertFalse(tytul.isEmpty(), "Tytuł nie powinien być pusty");
    }

    @Test
    @Order(4)
    @DisplayName("Test metody dajOpis() - zwracanie opisu")
    void testDajOpis() {
        // Jeśli: Film został utworzony z opisem "Cyberpunk thriller"

        // Gdy: Pobieramy opis filmu
        String opis = film.dajOpis();

        // Wtedy: Opis powinien być równy wartości podanej w konstruktorze
        assertNotNull(opis, "Opis nie powinien być null");
        assertEquals(TEST_OPIS, opis, "Opis powinien być równy wartości testowej");
    }

    @Test
    @Order(5)
    @DisplayName("Test metody dajCzasTrwania() - zwracanie czasu trwania")
    void testDajCzasTrwania() {
        // Jeśli: Film został utworzony z czasem trwania 136 minut

        // Gdy: Pobieramy czas trwania
        int czas = film.dajCzasTrwania();

        // Wtedy: Czas powinien być równy wartości podanej w konstruktorze
        assertEquals(TEST_CZAS, czas, "Czas trwania powinien być równy 136");
        assertTrue(czas > 0, "Czas trwania powinien być dodatni");
    }

    @Test
    @Order(6)
    @DisplayName("Test metody dajGatunek() - zwracanie gatunku")
    void testDajGatunek() {
        // Jeśli: Film został utworzony z gatunkiem "SciFi"

        // Gdy: Pobieramy gatunek filmu
        String gatunek = film.dajGatunek();

        // Wtedy: Gatunek powinien być równy wartości podanej w konstruktorze
        assertNotNull(gatunek, "Gatunek nie powinien być null");
        assertEquals(TEST_GATUNEK, gatunek, "Gatunek powinien być równy 'SciFi'");
    }

    @Test
    @Order(7)
    @DisplayName("Test metody dajCeneSeansow() - zwracanie ceny")
    void testDajCeneSeansow() {
        // Jeśli: Film został utworzony z ceną 28.5 PLN

        // Gdy: Pobieramy cenę seansów
        double cena = film.dajCeneSeansow();

        // Wtedy: Cena powinna być równa wartości podanej w konstruktorze
        assertEquals(TEST_CENA, cena, 0.01, "Cena powinna być równa 28.5");
        assertTrue(cena > 0, "Cena powinna być dodatnia");
    }

    // ========== TESTY PARAMETRYZOWANE - @CsvSource ==========

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test tworzenia filmów z różnymi danymi - @CsvSource")
    @CsvSource({
            "F001, Inception, Thriller psychologiczny, 148, Thriller, 32.0",
            "F002, Avatar, Fantasy SciFi, 162, SciFi, 35.0",
            "F003, Titanic, Romans epicki, 195, Dramat, 25.0",
            "F004, Joker, Studium postaci, 122, Dramat, 30.0"
    })
    void testTworzenieFilmowZRoznymiDanymi(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Dane filmu z parametrów CSV

        // Gdy: Tworzymy film z tymi danymi
        Film testFilm = new Film(id, tytul, opis, czas, gatunek, cena);

        // Wtedy: Wszystkie pola powinny być poprawnie ustawione
        assertEquals(id, testFilm.dajId(), "ID powinno być poprawne");
        assertEquals(tytul, testFilm.dajTytul(), "Tytuł powinien być poprawny");
        assertEquals(opis, testFilm.dajOpis(), "Opis powinien być poprawny");
        assertEquals(czas, testFilm.dajCzasTrwania(), "Czas powinien być poprawny");
        assertEquals(gatunek, testFilm.dajGatunek(), "Gatunek powinien być poprawny");
        assertEquals(cena, testFilm.dajCeneSeansow(), 0.01, "Cena powinna być poprawna");
    }

    // ========== TESTY PARAMETRYZOWANE - @ValueSource ==========

    @ParameterizedTest
    @Order(9)
    @DisplayName("Test filmów z różnymi czasami trwania - @ValueSource")
    @ValueSource(ints = { 60, 90, 120, 150, 180, 240 })
    void testFilmyZRoznymCzasemTrwania(int czas) {
        // Jeśli: Różne czasy trwania filmu

        // Gdy: Tworzymy film z określonym czasem
        Film testFilm = new Film("FT", "Test", "Opis", czas, "Gatunek", 20.0);

        // Wtedy: Czas trwania powinien być poprawnie zapisany
        assertEquals(czas, testFilm.dajCzasTrwania(),
                "Czas trwania powinien być równy " + czas);
        assertTrue(testFilm.dajCzasTrwania() > 0, "Czas powinien być dodatni");
    }

    @ParameterizedTest
    @Order(10)
    @DisplayName("Test filmów z różnymi cenami - @ValueSource")
    @ValueSource(doubles = { 10.0, 15.5, 20.0, 25.99, 30.0, 35.5, 50.0 })
    void testFilmyZRoznaCena(double cena) {
        // Jeśli: Różne ceny seansów

        // Gdy: Tworzymy film z określoną ceną
        Film testFilm = new Film("FT", "Test", "Opis", 120, "Gatunek", cena);

        // Wtedy: Cena powinna być poprawnie zapisana
        assertEquals(cena, testFilm.dajCeneSeansow(), 0.01,
                "Cena powinna być równa " + cena);
        assertTrue(testFilm.dajCeneSeansow() >= 10.0, "Cena powinna być >= 10.0");
    }

    // ========== TESTY WARTOŚCI BRZEGOWYCH ==========

    @Test
    @Order(11)
    @DisplayName("Test filmu z minimalnym czasem trwania")
    void testFilmMinimalnyCzas() {
        // Jeśli: Film ma minimalny czas trwania (1 minuta)

        // Gdy: Tworzymy film z czasem 1 minuty
        Film krotki = new Film("FK", "Krótki", "Opis", 1, "Short", 5.0);

        // Wtedy: Film powinien być poprawnie utworzony
        assertEquals(1, krotki.dajCzasTrwania());
        assertNotNull(krotki.dajTytul());
    }

    @Test
    @Order(12)
    @DisplayName("Test filmu z bardzo długim czasem trwania")
    void testFilmDlugiCzas() {
        // Jeśli: Film ma bardzo długi czas trwania

        // Gdy: Tworzymy film z czasem 300 minut
        Film dlugi = new Film("FD", "Długi", "Opis", 300, "Epic", 40.0);

        // Wtedy: Film powinien być poprawnie utworzony
        assertEquals(300, dlugi.dajCzasTrwania());
        assertTrue(dlugi.dajCzasTrwania() > 180, "Film powinien być dłuższy niż 3 godziny");
    }

    // ========== TESTY NIEZMIENNICZOŚCI ==========

    @Test
    @Order(13)
    @DisplayName("Test niezmienniczości danych filmu")
    void testNiezmiennoscDanych() {
        // Jeśli: Film został utworzony z określonymi danymi
        String originalId = film.dajId();
        String originalTytul = film.dajTytul();
        double originalCena = film.dajCeneSeansow();

        // Gdy: Pobieramy dane wielokrotnie
        String id2 = film.dajId();
        String tytul2 = film.dajTytul();
        double cena2 = film.dajCeneSeansow();

        // Wtedy: Dane powinny pozostać niezmienione
        assertSame(originalId, id2, "ID nie powinno się zmienić");
        assertSame(originalTytul, tytul2, "Tytuł nie powinien się zmienić");
        assertEquals(originalCena, cena2, 0.001, "Cena nie powinna się zmienić");
    }
}

\end{lstlisting}

\newpage

\subsubsection{model.TestDAO}
Plik: \texttt{src/test/java/model/TestDAO.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy DAO.
 * Testuje operacje dodawania i wyszukiwania danych.
 */
@DisplayName("Testy klasy DAO")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("dodawanie")
class TestDAO {

    private DAO dao;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów DAO");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie nowego DAO przed każdym testem
        dao = new DAO();
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów DAO");
    }

    @Test
    @Order(1)
    @DisplayName("Test dodawania filmu i generowania ID")
    void testDodajFilm() {
        // Jeśli: Dane filmu do zapisania
        String daneFilmu = "F001;Avengers;Superbohaterowie;150;Akcja;30.0";

        // Gdy: Dodajemy film do DAO
        String id = dao.dodajFilm(daneFilmu);

        // Wtedy: ID powinno być wygenerowane i film powinien być zapisany
        assertNotNull(id, "ID nie powinno być null");
        assertTrue(id.startsWith("F"), "ID powinno zaczynać się od F");
        assertEquals("F001", id, "ID powinno być F001");
    }

    @Test
    @Order(2)
    @DisplayName("Test znajdowania filmu po ID")
    void testZnajdzFilm() {
        // Jeśli: Film został dodany do DAO
        String daneFilmu = "F1;Matrix;SciFi;136;Akcja;28.0";
        String id = dao.dodajFilm(daneFilmu);

        // Gdy: Szukamy filmu po ID
        String znalezionyFilm = dao.znajdzFilm(id);

        // Wtedy: Powinniśmy znaleźć ten sam film
        assertNotNull(znalezionyFilm, "Film powinien zostać znaleziony");
        assertEquals(daneFilmu, znalezionyFilm, "Dane filmu powinny być identyczne");
    }

    @Test
    @Order(3)
    @DisplayName("Test szukania nieistniejącego filmu")
    void testZnajdzFilmNieistniejacy() {
        // Jeśli: DAO jest puste

        // Gdy: Szukamy nieistniejącego filmu
        String znalezionyFilm = dao.znajdzFilm("F999");

        // Wtedy: Powinniśmy otrzymać null
        assertNull(znalezionyFilm, "Nieistniejący film powinien zwrócić null");
    }

    @ParameterizedTest
    @Order(4)
    @DisplayName("Test dodawania filmów z różnymi ID")
    @CsvSource({
            "F1;Film1;Opis1;90;Komedia;20.0, F2;Film2;Opis2;120;Dramat;25.0, F3;Film3;Opis3;110;Akcja;30.0",
            "F10;KomediaX;OpisX;95;Komedia;18.0, F11;DramatY;OpisY;125;Dramat;22.5, F12;AkcjaZ;OpisZ;100;Akcja;27.0"
    })
    void testInkrementacjaIdFilmow(String film1, String film2, String film3) {
        // Jeśli: Dane kilku filmów (parametryzowane)

        // Gdy: Dodajemy filmy kolejno
        String id1 = dao.dodajFilm(film1);
        String id2 = dao.dodajFilm(film2);
        String id3 = dao.dodajFilm(film3);

        // Wtedy: ID powinny być takie same jak w danych
        String[] parts1 = film1.split(";");
        String[] parts2 = film2.split(";");
        String[] parts3 = film3.split(";");
        assertEquals(parts1[0], id1);
        assertEquals(parts2[0], id2);
        assertEquals(parts3[0], id3);
        assertNotEquals(id1, id2, "ID powinny być różne");
    }

    @Test
    @Order(5)
    @DisplayName("Test dodawania wpisu do logu")
    void testDodajWpisDoLogu() {
        // Jeśli: Treść zdarzenia do zalogowania
        String zdarzenie = "Test zdarzenia";

        // Gdy: Dodajemy wpis do logu
        // Wtedy: Nie powinien wystąpić wyjątek
        assertDoesNotThrow(() -> {
            dao.dodajWpisDoLogu(zdarzenie);
        }, "Dodawanie wpisu do logu nie powinno rzucić wyjątku");
    }

    @ParameterizedTest
    @Order(6)
    @DisplayName("Test dodawania filmów o różnych cenach")
    @ValueSource(doubles = { 10.0, 15.5, 20.0, 25.99, 30.0 })
    void testDodajFilmyRozneCeny(double cena) {
        // Jeśli: Dane filmu z różnymi cenami
        String daneFilmu = "FX;Film;Opis;120;Gatunek;" + cena;

        // Gdy: Dodajemy film
        String id = dao.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być zapisany
        assertNotNull(id);
        String znalezionyFilm = dao.znajdzFilm(id);
        assertTrue(znalezionyFilm.contains(String.valueOf(cena)),
                "Znaleziony film powinien zawierać cenę");
    }
}

\end{lstlisting}

\newpage

\subsubsection{model.TestFabrykaStandardowegoFilmu}
Plik: \texttt{src/test/java/model/TestFabrykaStandardowegoFilmu.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy FabrykaStandardowegoFilmu.
 * Testuje tworzenie filmów z danych wejściowych.
 */
@DisplayName("Testy klasy FabrykaStandardowegoFilmu")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("dodawanie")
class TestFabrykaStandardowegoFilmu {

    private FabrykaStandardowegoFilmu fabryka;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów FabrykaStandardowegoFilmu");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie fabryki przed każdym testem
        fabryka = new FabrykaStandardowegoFilmu();
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        fabryka = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów FabrykaStandardowegoFilmu");
    }

    @Test
    @Order(1)
    @DisplayName("Test tworzenia filmu z poprawnych danych")
    void testUtworzFilmPoprawne() {
        // Jeśli: Dane filmu w formacie CSV
        String daneFilmu = "F001;Avengers;Superbohaterowie;150;Akcja;30.0";

        // Gdy: Tworzymy film używając fabryki
        IFilm film = fabryka.utworzFilm(daneFilmu);

        // Wtedy: Film powinien być utworzony z poprawnymi danymi
        assertNotNull(film, "Film nie powinien być null");
        assertEquals("Avengers", film.dajTytul());
        assertEquals("Superbohaterowie", film.dajOpis());
        assertEquals(150, film.dajCzasTrwania());
        assertEquals(30.0, film.dajCeneSeansow(), 0.01);
    }

    @Test
    @Order(2)
    @DisplayName("Test tworzenia filmu z minimalnymi danymi")
    void testUtworzFilmMinimalne() {
        // Jeśli: Minimalne dane filmu
        String daneFilmu = "F002;Film;Opis;60;Dramat;10.0";

        // Gdy: Tworzymy film
        IFilm film = fabryka.utworzFilm(daneFilmu);

        // Wtedy: Film powinien być utworzony
        assertNotNull(film);
        assertTrue(film.dajCzasTrwania() > 0, "Czas trwania powinien być dodatni");
        assertTrue(film.dajCeneSeansow() > 0, "Cena powinna być dodatnia");
    }

    @ParameterizedTest
    @Order(3)
    @DisplayName("Test tworzenia filmów z różnymi danymi wejściowymi")
    @CsvSource({
            "F001, Titanic, Romans na statku, 195, Dramat, 25.0",
            "F002, Matrix, Cyberpunk, 136, SciFi, 28.5",
            "F003, Joker, Psychologiczny, 122, Thriller, 32.0"
    })
    void testUtworzFilmParametryzowany(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Dane filmu z różnych źródeł
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;

        // Gdy: Tworzymy film
        IFilm film = fabryka.utworzFilm(daneFilmu);

        // Wtedy: Wszystkie pola powinny być poprawnie ustawione
        assertEquals(id, film.dajId());
        assertEquals(tytul, film.dajTytul());
        assertEquals(opis, film.dajOpis());
        assertEquals(czas, film.dajCzasTrwania());
        assertEquals(cena, film.dajCeneSeansow(), 0.01);
    }

    @ParameterizedTest
    @Order(4)
    @DisplayName("Test tworzenia filmów z różnymi cenami")
    @MethodSource("dostarczDaneFilmow")
    void testUtworzFilmZMetody(String daneFilmu, double oczekiwanaCena) {
        // Jeśli: Dane filmu dostarczone z metody

        // Gdy: Tworzymy film
        IFilm film = fabryka.utworzFilm(daneFilmu);

        // Wtedy: Cena powinna odpowiadać oczekiwanej
        assertNotNull(film);
        assertEquals(oczekiwanaCena, film.dajCeneSeansow(), 0.01);
        assertFalse(film.dajTytul().isEmpty(), "Tytuł nie powinien być pusty");
    }

    static Stream<org.junit.jupiter.params.provider.Arguments> dostarczDaneFilmow() {
        return Stream.of(
                org.junit.jupiter.params.provider.Arguments.of("F001;Film1;Opis1;90;Komedia;15.0", 15.0),
                org.junit.jupiter.params.provider.Arguments.of("F002;Film2;Opis2;120;Akcja;22.5", 22.5),
                org.junit.jupiter.params.provider.Arguments.of("F003;Film3;Opis3;100;Dramat;18.99", 18.99));
    }

    @Test
    @Order(5)
    @DisplayName("Test wyjątku przy niepoprawnych danych")
    void testUtworzFilmNiepoprawne() {
        // Jeśli: Niepoprawne dane wejściowe (brak wystarczającej liczby pól)
        String daneFilmu = "F001;Film";

        // Gdy/Wtedy: Powinien wystąpić wyjątek
        assertThrows(Exception.class, () -> {
            fabryka.utworzFilm(daneFilmu);
        }, "Powinien wystąpić wyjątek przy niepoprawnych danych");
    }
}

\end{lstlisting}

\newpage

\subsubsection{model.TestModelDodawanieFilmu}
Plik: \texttt{src/test/java/model/TestModelDodawanieFilmu.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy Model - operacja dodawania filmu.
 * Testuje pełny przepływ dodawania filmu przez warstwę modelu.
 */
@DisplayName("Testy klasy Model - dodawanie filmu")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("dodawanie")
class TestModelDodawanieFilmu {

    private Model model;
    private DAO dao;
    private Oferta oferta;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów Model - dodawanie filmu");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie systemu przed każdym testem
        dao = new DAO();
        oferta = new Oferta(dao);
        model = new Model(oferta, dao);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        model = null;
        oferta = null;
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów Model - dodawanie filmu");
    }

    @Test
    @Order(1)
    @DisplayName("Test dodawania filmu przez Model")
    void testDodajFilm() {
        // Jeśli: Dane filmu w formacie CSV
        String daneFilmu = "F001;Avengers;Superbohaterowie ratują świat;150;Akcja;30.0";

        // Gdy: Dodajemy film przez model
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany z komunikatem sukcesu
        assertNotNull(wynik, "Wynik nie powinien być null");
        assertTrue(wynik.contains("pomyslnie"), "Wynik powinien zawierać 'pomyslnie'");
        assertTrue(wynik.contains("ID"), "Wynik powinien zawierać ID");
        assertFalse(wynik.isEmpty(), "Wynik nie powinien być pusty");
    }

    @Test
    @Order(2)
    @DisplayName("Test dodawania filmu i weryfikacja w DAO")
    void testDodajFilmWeryfikacjaDAO() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;Matrix;Cyberpunk thriller;136;SciFi;28.5";

        // Gdy: Dodajemy film
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien istnieć w DAO
        assertTrue(wynik.contains("F001"), "Wynik powinien zawierać ID F001");
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm, "Film powinien być zapisany w DAO");
        assertTrue(zapisanyFilm.contains("Matrix"), "Zapisany film powinien zawierać tytuł");
    }

    @Test
    @Order(3)
    @DisplayName("Test formatu komunikatu zwrotnego")
    void testFormatKomunikatu() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;Titanic;Romans;195;Dramat;25.0";

        // Gdy: Dodajemy film
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Komunikat powinien mieć odpowiedni format
        assertTrue(wynik.startsWith("Film dodany"), "Komunikat powinien zaczynać się od 'Film dodany'");
        assertTrue(wynik.contains("ID:"), "Komunikat powinien zawierać 'ID:'");
    }

    @Test
    @Order(4)
    @DisplayName("Test dodawania wielu filmów")
    void testDodajWieleFilmow() {
        // Jeśli: Dane kilku filmów
        String film1 = "F001;Film1;Opis1;90;Komedia;20.0";
        String film2 = "F002;Film2;Opis2;120;Dramat;25.0";
        String film3 = "F003;Film3;Opis3;110;Akcja;30.0";

        // Gdy: Dodajemy filmy kolejno
        String wynik1 = model.dodajFilm(film1);
        String wynik2 = model.dodajFilm(film2);
        String wynik3 = model.dodajFilm(film3);

        // Wtedy: Wszystkie filmy powinny być dodane z różnymi ID
        assertTrue(wynik1.contains("F001"));
        assertTrue(wynik2.contains("F002"));
        assertTrue(wynik3.contains("F003"));
        assertNotEquals(wynik1, wynik2, "Wyniki powinny być różne");
        assertNotEquals(wynik2, wynik3, "Wyniki powinny być różne");
    }

    @ParameterizedTest
    @Order(5)
    @DisplayName("Test dodawania filmów z różnymi danymi")
    @CsvSource({
            "F001, Inception, Thriller psychologiczny, 148, Thriller, 32.0",
            "F002, Joker, Studium postaci, 122, Dramat, 30.0",
            "F003, Parasite, Społeczny dramat, 132, Dramat, 28.0"
    })
    void testDodajFilmParametryzowany(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Dane filmu z parametrów
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;

        // Gdy: Dodajemy film
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"), "Wynik powinien zawierać potwierdzenie");
        assertTrue(wynik.contains("ID:"), "Wynik powinien zawierać ID");
    }

    @ParameterizedTest
    @Order(6)
    @DisplayName("Test dodawania filmów z metodą źródłową")
    @MethodSource("dostarczDaneFilmow")
    void testDodajFilmZMetody(String daneFilmu, String oczekiwanyTytul) {
        // Jeśli: Dane filmu z metody źródłowej

        // Gdy: Dodajemy film
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany i dostępny w DAO
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Weryfikacja w DAO
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm, "Film powinien być w DAO");
        assertTrue(zapisanyFilm.contains(oczekiwanyTytul),
                "Film powinien zawierać oczekiwany tytuł");
    }

    static Stream<org.junit.jupiter.params.provider.Arguments> dostarczDaneFilmow() {
        return Stream.of(
                org.junit.jupiter.params.provider.Arguments.of(
                        "F001;Avatar;Fantasy SciFi;162;SciFi;35.0", "Avatar"),
                org.junit.jupiter.params.provider.Arguments.of(
                        "F002;Gladiator;Historyczny;155;Akcja;27.0", "Gladiator"),
                org.junit.jupiter.params.provider.Arguments.of(
                        "F003;Interstellar;Kosmos;169;SciFi;33.0", "Interstellar"));
    }

    @Test
    @Order(7)
    @DisplayName("Test integracji fabryki z modelem")
    void testIntegracjaFabryki() {
        // Jeśli: Dane filmu wymagające przetworzenia przez fabrykę
        String daneFilmu = "F001;TestFilm;TestOpis;100;TestGatunek;20.0";

        // Gdy: Dodajemy film (co używa fabryki wewnętrznie)
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być utworzony przez fabrykę i zapisany
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Weryfikacja że dane zostały przetworzone
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm);
        assertTrue(zapisanyFilm.contains("TestFilm"));
        assertTrue(zapisanyFilm.contains("20.0"));
    }
}

\end{lstlisting}

\newpage

\subsubsection{controller.TestAdminControllerDodawanieFilmu}
Plik: \texttt{src/test/java/controller/TestAdminControllerDodawanieFilmu.java}

\begin{lstlisting}
package controller;

import model.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy AdminController - operacja dodawania filmu.
 * Testuje pełny przepływ dodawania filmu przez kontroler administratora.
 */
@DisplayName("Testy klasy AdminController - dodawanie filmu")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("kontroler")
@Tag("dodawanie")
class TestAdminControllerDodawanieFilmu {

    private AdminController adminController;
    private Model model;
    private DAO dao;
    private Oferta oferta;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów AdminController - dodawanie filmu");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie pełnego systemu przed każdym testem
        dao = new DAO();
        oferta = new Oferta(dao);
        model = new Model(oferta, dao);
        adminController = new AdminController(model);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        adminController = null;
        model = null;
        oferta = null;
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów AdminController - dodawanie filmu");
    }

    @Test
    @Order(1)
    @DisplayName("Test dodawania filmu przez AdminController")
    void testDodajFilm() {
        // Jeśli: Dane filmu w formacie CSV
        String daneFilmu = "F001;Avengers;Superbohaterowie;150;Akcja;30.0";

        // Gdy: Dodajemy film przez kontroler
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany pomyślnie
        assertNotNull(wynik, "Wynik nie powinien być null");
        assertTrue(wynik.contains("pomyslnie"), "Wynik powinien zawierać 'pomyslnie'");
        assertTrue(wynik.contains("ID"), "Wynik powinien zawierać ID filmu");
    }

    @Test
    @Order(2)
    @DisplayName("Test dodawania filmu i weryfikacja zapisu")
    void testDodajFilmWeryfikacja() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;Matrix;Cyberpunk;136;SciFi;28.5";

        // Gdy: Dodajemy film
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być w systemie
        assertTrue(wynik.contains("F001"), "Wynik powinien zawierać ID");

        // Weryfikacja w DAO
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm, "Film powinien być zapisany w bazie");
        assertTrue(zapisanyFilm.contains("Matrix"), "Film powinien zawierać poprawny tytuł");
    }

    @Test
    @Order(3)
    @DisplayName("Test wzorca Strategy w dodawaniu filmu")
    void testStrategiaEdycjiOferty() {
        // Jeśli: Dane filmu do dodania
        String daneFilmu = "F001;Inception;Thriller;148;Thriller;32.0";

        // Gdy: Dodajemy film (używa strategii DodanieNowegoFilmu)
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Strategia powinna zostać poprawnie wykonana
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"), "Strategia powinna wykonać się pomyślnie");
        assertFalse(wynik.isEmpty(), "Wynik nie powinien być pusty");
    }

    @Test
    @Order(4)
    @DisplayName("Test dodawania wielu filmów sekwencyjnie")
    void testDodajWieleFilmow() {
        // Jeśli: Dane kilku filmów
        String film1 = "F001;Film1;Opis1;90;Komedia;20.0";
        String film2 = "F002;Film2;Opis2;120;Dramat;25.0";
        String film3 = "F003;Film3;Opis3;110;Akcja;30.0";

        // Gdy: Dodajemy filmy kolejno
        String wynik1 = adminController.dodajFilm(film1);
        String wynik2 = adminController.dodajFilm(film2);
        String wynik3 = adminController.dodajFilm(film3);

        // Wtedy: Wszystkie filmy powinny być dodane z unikalnymi ID
        assertTrue(wynik1.contains("F001"), "Pierwszy film powinien mieć ID F001");
        assertTrue(wynik2.contains("F002"), "Drugi film powinien mieć ID F002");
        assertTrue(wynik3.contains("F003"), "Trzeci film powinien mieć ID F003");

        // Weryfikacja w DAO
        assertNotNull(dao.znajdzFilm("F001"));
        assertNotNull(dao.znajdzFilm("F002"));
        assertNotNull(dao.znajdzFilm("F003"));
    }

    @Test
    @Order(5)
    @DisplayName("Test poprawności formatu komunikatu")
    void testFormatKomunikatu() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;Titanic;Romans;195;Dramat;25.0";

        // Gdy: Dodajemy film
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Komunikat powinien mieć określony format
        assertTrue(wynik.startsWith("Film dodany"),
                "Komunikat powinien zaczynać się od 'Film dodany'");
        assertTrue(wynik.contains("ID:"), "Komunikat powinien zawierać 'ID:'");
        assertTrue(wynik.contains("F"), "Komunikat powinien zawierać prefix ID");
    }

    @ParameterizedTest
    @Order(6)
    @DisplayName("Test dodawania filmów z różnymi danymi")
    @CsvSource({
            "F001, Parasite, Dramat społeczny, 132, Dramat, 28.0",
            "F002, Joker, Psychologiczny, 122, Thriller, 30.0",
            "F003, 1917, Wojenny, 119, Wojenny, 27.5",
            "F004, Dune, Epicka SF, 155, SciFi, 35.0"
    })
    void testDodajFilmParametryzowany(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Dane filmu z parametrów
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;

        // Gdy: Dodajemy film
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany
        assertNotNull(wynik, "Wynik nie powinien być null");
        assertTrue(wynik.contains("pomyslnie"), "Film powinien być dodany pomyślnie");
        assertTrue(wynik.contains("ID:"), "Wynik powinien zawierać ID");
    }

    @ParameterizedTest
    @Order(7)
    @DisplayName("Test dodawania filmów o różnych cenach")
    @ValueSource(doubles = { 10.0, 15.5, 20.0, 25.99, 30.0, 35.5, 40.0 })
    void testDodajFilmRozneCeny(double cena) {
        // Jeśli: Dane filmu z różnymi cenami
        String daneFilmu = "F" + ((int) (cena * 10)) + ";Film;Opis;120;Gatunek;" + cena;

        // Gdy: Dodajemy film
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być dodany niezależnie od ceny
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Weryfikacja że cena jest zapisana
        String zapisanyFilm = dao.znajdzFilm("F" + ((int) (cena * 10)));
        assertNotNull(zapisanyFilm);
        assertTrue(zapisanyFilm.contains(String.valueOf(cena)),
                "Zapisany film powinien zawierać cenę");
    }

    @Test
    @Order(8)
    @DisplayName("Test pełnego przepływu dodawania filmu")
    void testPelnyPrzeplyw() {
        // Jeśli: Kompletne dane filmu
        String daneFilmu = "F001;Avatar;Fantasy epicki;162;SciFi;35.0";

        // Gdy: Dodajemy film przez AdminController
        // (co wywołuje EdytowanieOfertyKina -> DodanieNowegoFilmu -> Model -> Fabryka
        // -> DAO)
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Cały przepływ powinien zakończyć się sukcesem
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Weryfikacja na poziomie DAO
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm, "Film powinien być w bazie danych");
        assertTrue(zapisanyFilm.contains("Avatar"), "Film powinien mieć poprawny tytuł");
        assertTrue(zapisanyFilm.contains("35.0"), "Film powinien mieć poprawną cenę");
    }

    @Test
    @Order(9)
    @DisplayName("Test że AdminController nie modyfikuje danych filmu")
    void testNiezmiennoscDanych() {
        // Jeśli: Oryginalne dane filmu
        String oryginalneDane = "F001;Original;Description;100;Genre;20.0";

        // Gdy: Dodajemy film
        String wynik = adminController.dodajFilm(oryginalneDane);

        // Wtedy: Dane w DAO powinny odpowiadać oryginalnym
        String zapisanyFilm = dao.znajdzFilm("F001");
        assertNotNull(zapisanyFilm);
        assertTrue(zapisanyFilm.contains("Original"), "Tytuł nie powinien być zmieniony");
        assertTrue(zapisanyFilm.contains("Description"), "Opis nie powinien być zmieniony");
        assertTrue(zapisanyFilm.contains("100"), "Czas nie powinien być zmieniony");
        assertTrue(zapisanyFilm.contains("20.0"), "Cena nie powinna być zmieniona");
    }
}

\end{lstlisting}

\newpage

\subsection{Przypadek użycia: Przeglądanie repertuaru}

W tym zadaniu testujemy klasy bez symulacji zależności (bez mockowania).

\subsubsection{model.TestSeans}
Plik: \texttt{src/test/java/model/TestSeans.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy Seans.
 * Testuje encję danych seansu - podstawową strukturę przechowującą informacje o
 * seansie filmowym.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Encja (model)
 * Zadanie: 1 (testy bez mockowania)
 */
@DisplayName("Testy klasy Seans - encja danych")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("repertuar")
class TestSeans {

    // Dane testowe przygotowywane przed każdym testem
    private Seans seans;
    private Film filmTestowy;
    private static final String TEST_ID = "S001";
    private static final String TEST_DATA = "2024-12-20 18:00";
    private static final String TEST_SALA = "Sala1";
    private static final int TEST_MIEJSCA = 100;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów klasy Seans");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Przygotowanie danych testowych przed każdym testem
        // Tworzymy film testowy potrzebny do seansu
        filmTestowy = new Film("F001", "Matrix", "Cyberpunk thriller", 136, "SciFi", 28.5);
        // Tworzymy nowy obiekt Seans z określonymi danymi
        seans = new Seans(TEST_ID, filmTestowy, TEST_DATA, TEST_SALA, TEST_MIEJSCA);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        seans = null;
        filmTestowy = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów klasy Seans");
    }

    // ========== TESTY KONSTRUKTORA ==========

    @Test
    @Order(1)
    @DisplayName("Test tworzenia seansu przez konstruktor")
    void testTworzenieSeansu() {
        // Jeśli: Dane do utworzenia seansu zostały przygotowane w setUp()

        // Gdy: Seans został utworzony w setUp()

        // Wtedy: Obiekt seansu nie powinien być null i powinien mieć poprawne dane
        assertNotNull(seans, "Seans nie powinien być null po utworzeniu");
        assertInstanceOf(Seans.class, seans, "Obiekt powinien być instancją klasy Seans");
        assertTrue(seans instanceof ISeans, "Seans powinien implementować interfejs ISeans");
    }

    // ========== TESTY GETTERÓW ==========

    @Test
    @Order(2)
    @DisplayName("Test metody dajId() - zwracanie identyfikatora seansu")
    void testDajId() {
        // Jeśli: Seans został utworzony z ID = "S001"

        // Gdy: Pobieramy ID seansu
        String id = seans.dajId();

        // Wtedy: ID powinno być równe wartości podanej w konstruktorze
        assertNotNull(id, "ID nie powinno być null");
        assertEquals(TEST_ID, id, "ID powinno być równe 'S001'");
        assertTrue(id.startsWith("S"), "ID powinno zaczynać się od 'S'");
    }

    @Test
    @Order(3)
    @DisplayName("Test metody dajFilm() - zwracanie filmu seansu")
    void testDajFilm() {
        // Jeśli: Seans został utworzony z filmem "Matrix"

        // Gdy: Pobieramy film seansu
        IFilm film = seans.dajFilm();

        // Wtedy: Film powinien być równy filmowi podanemu w konstruktorze
        assertNotNull(film, "Film nie powinien być null");
        assertEquals(filmTestowy, film, "Film powinien być tym samym obiektem");
        assertEquals("Matrix", film.dajTytul(), "Tytuł filmu powinien być 'Matrix'");
    }

    @Test
    @Order(4)
    @DisplayName("Test metody dajDate() - zwracanie daty seansu")
    void testDajDate() {
        // Jeśli: Seans został utworzony z datą "2024-12-20 18:00"

        // Gdy: Pobieramy datę seansu
        String data = seans.dajDate();

        // Wtedy: Data powinna być równa wartości podanej w konstruktorze
        assertNotNull(data, "Data nie powinna być null");
        assertEquals(TEST_DATA, data, "Data powinna być równa wartości testowej");
        assertFalse(data.isEmpty(), "Data nie powinna być pusta");
    }

    @Test
    @Order(5)
    @DisplayName("Test metody dajWolneMiejsca() - początkowa liczba wolnych miejsc")
    void testDajWolneMiejscaPoczatkowo() {
        // Jeśli: Seans został utworzony z 100 miejscami, żadne nie jest zajęte

        // Gdy: Pobieramy wolne miejsca
        int[] wolneMiejsca = seans.dajWolneMiejsca();

        // Wtedy: Wszystkie miejsca powinny być wolne
        assertNotNull(wolneMiejsca, "Tablica wolnych miejsc nie powinna być null");
        assertEquals(TEST_MIEJSCA, wolneMiejsca.length, "Wszystkie 100 miejsc powinno być wolnych");
        assertEquals(1, wolneMiejsca[0], "Pierwsze wolne miejsce powinno mieć numer 1");
        assertEquals(100, wolneMiejsca[99], "Ostatnie wolne miejsce powinno mieć numer 100");
    }

    // ========== TESTY REZERWACJI MIEJSC ==========

    @Test
    @Order(6)
    @DisplayName("Test zarezerwujMiejsce() - udana rezerwacja")
    void testZarezerwujMiejsceUdana() {
        // Jeśli: Miejsce nr 50 jest wolne

        // Gdy: Rezerwujemy miejsce nr 50
        boolean wynik = seans.zarezerwujMiejsce(50);

        // Wtedy: Rezerwacja powinna się udać
        assertTrue(wynik, "Rezerwacja powinna się udać");

        // I liczba wolnych miejsc powinna się zmniejszyć o 1
        int[] wolneMiejsca = seans.dajWolneMiejsca();
        assertEquals(99, wolneMiejsca.length, "Powinno być 99 wolnych miejsc");
    }

    @Test
    @Order(7)
    @DisplayName("Test zarezerwujMiejsce() - próba rezerwacji zajętego miejsca")
    void testZarezerwujMiejsceZajete() {
        // Jeśli: Miejsce nr 25 zostało już zarezerwowane
        seans.zarezerwujMiejsce(25);

        // Gdy: Próbujemy zarezerwować to samo miejsce ponownie
        boolean wynik = seans.zarezerwujMiejsce(25);

        // Wtedy: Rezerwacja powinna się nie udać
        assertFalse(wynik, "Rezerwacja zajętego miejsca powinna się nie udać");
    }

    @Test
    @Order(8)
    @DisplayName("Test zarezerwujMiejsce() - nieprawidłowy numer miejsca")
    void testZarezerwujMiejsceNieprawidlowe() {
        // Jeśli: Seans ma 100 miejsc (numery 1-100)

        // Gdy: Próbujemy zarezerwować miejsce o numerze 0 lub 101
        boolean wynik0 = seans.zarezerwujMiejsce(0);
        boolean wynik101 = seans.zarezerwujMiejsce(101);
        boolean wynikUjemny = seans.zarezerwujMiejsce(-5);

        // Wtedy: Wszystkie rezerwacje powinny się nie udać
        assertFalse(wynik0, "Rezerwacja miejsca 0 powinna się nie udać");
        assertFalse(wynik101, "Rezerwacja miejsca 101 powinna się nie udać");
        assertFalse(wynikUjemny, "Rezerwacja miejsca -5 powinna się nie udać");
    }

    @Test
    @Order(9)
    @DisplayName("Test zwolnijMiejsce() - zwalnianie zarezerwowanego miejsca")
    void testZwolnijMiejsce() {
        // Jeśli: Miejsce nr 30 zostało zarezerwowane
        seans.zarezerwujMiejsce(30);
        int wolnychPoRezerwacji = seans.dajWolneMiejsca().length;

        // Gdy: Zwalniamy miejsce nr 30
        seans.zwolnijMiejsce(30);

        // Wtedy: Miejsce powinno być ponownie dostępne
        int wolnychPoZwolnieniu = seans.dajWolneMiejsca().length;
        assertEquals(wolnychPoRezerwacji + 1, wolnychPoZwolnieniu,
                "Liczba wolnych miejsc powinna wzrosnąć o 1");
    }

    // ========== TESTY PARAMETRYZOWANE - @CsvSource ==========

    @ParameterizedTest
    @Order(10)
    @DisplayName("Test tworzenia seansów z różnymi danymi - @CsvSource")
    @CsvSource({
            "S001, 2024-12-20 18:00, Sala1, 100",
            "S002, 2024-12-21 20:30, Sala2, 150",
            "S003, 2024-12-22 15:00, SalaVIP, 50",
            "S004, 2024-12-23 21:00, Sala3, 200"
    })
    void testTworzenieSeansowZRoznymiDanymi(String id, String data, String sala, int miejsca) {
        // Jeśli: Dane seansu z parametrów CSV

        // Gdy: Tworzymy seans z tymi danymi
        Seans testSeans = new Seans(id, filmTestowy, data, sala, miejsca);

        // Wtedy: Wszystkie pola powinny być poprawnie ustawione
        assertEquals(id, testSeans.dajId(), "ID powinno być poprawne");
        assertEquals(data, testSeans.dajDate(), "Data powinna być poprawna");
        assertEquals(miejsca, testSeans.dajWolneMiejsca().length, "Liczba miejsc powinna być poprawna");
        assertNotNull(testSeans.dajFilm(), "Film nie powinien być null");
    }

    // ========== TESTY PARAMETRYZOWANE - @ValueSource ==========

    @ParameterizedTest
    @Order(11)
    @DisplayName("Test seansów z różną liczbą miejsc - @ValueSource")
    @ValueSource(ints = { 20, 50, 100, 150, 200, 300 })
    void testSeanseZRoznaLiczbaMiejsc(int liczbaMiejsc) {
        // Jeśli: Różne liczby miejsc w sali

        // Gdy: Tworzymy seans z określoną liczbą miejsc
        Seans testSeans = new Seans("ST", filmTestowy, "2024-12-25 12:00", "TestSala", liczbaMiejsc);

        // Wtedy: Liczba wolnych miejsc powinna być poprawna
        assertEquals(liczbaMiejsc, testSeans.dajWolneMiejsca().length,
                "Liczba wolnych miejsc powinna być równa " + liczbaMiejsc);
    }

    @ParameterizedTest
    @Order(12)
    @DisplayName("Test rezerwacji różnych numerów miejsc - @ValueSource")
    @ValueSource(ints = { 1, 25, 50, 75, 100 })
    void testRezerwacjaRoznychMiejsc(int nrMiejsca) {
        // Jeśli: Różne numery miejsc do rezerwacji

        // Gdy: Rezerwujemy określone miejsce
        boolean wynik = seans.zarezerwujMiejsce(nrMiejsca);

        // Wtedy: Rezerwacja powinna się udać
        assertTrue(wynik, "Rezerwacja miejsca " + nrMiejsca + " powinna się udać");
        assertEquals(99, seans.dajWolneMiejsca().length, "Powinno być 99 wolnych miejsc");
    }

    // ========== TESTY WARTOŚCI BRZEGOWYCH ==========

    @Test
    @Order(13)
    @DisplayName("Test rezerwacji pierwszego i ostatniego miejsca")
    void testRezerwacjaMiejscBrzegowych() {
        // Jeśli: Seans ma 100 miejsc

        // Gdy: Rezerwujemy pierwsze i ostatnie miejsce
        boolean pierwszeUdane = seans.zarezerwujMiejsce(1);
        boolean ostatnieUdane = seans.zarezerwujMiejsce(100);

        // Wtedy: Obie rezerwacje powinny się udać
        assertTrue(pierwszeUdane, "Rezerwacja miejsca 1 powinna się udać");
        assertTrue(ostatnieUdane, "Rezerwacja miejsca 100 powinna się udać");
        assertEquals(98, seans.dajWolneMiejsca().length, "Powinno być 98 wolnych miejsc");
    }

    @Test
    @Order(14)
    @DisplayName("Test seansu z minimalną liczbą miejsc")
    void testSeanseMinimalnaLiczbaMiejsc() {
        // Jeśli: Seans ma tylko 1 miejsce

        // Gdy: Tworzymy seans z 1 miejscem
        Seans maly = new Seans("SM", filmTestowy, "2024-12-25 12:00", "MicroSala", 1);

        // Wtedy: Powinno być 1 wolne miejsce
        assertEquals(1, maly.dajWolneMiejsca().length, "Powinno być 1 wolne miejsce");

        // I rezerwacja powinna się udać
        assertTrue(maly.zarezerwujMiejsce(1), "Rezerwacja jedynego miejsca powinna się udać");
        assertEquals(0, maly.dajWolneMiejsca().length, "Powinno być 0 wolnych miejsc po rezerwacji");
    }

    // ========== TESTY NIEZMIENNICZOŚCI ==========

    @Test
    @Order(15)
    @DisplayName("Test niezmienniczości danych seansu")
    void testNiezmiennoscDanych() {
        // Jeśli: Seans został utworzony z określonymi danymi
        String originalId = seans.dajId();
        String originalData = seans.dajDate();
        IFilm originalFilm = seans.dajFilm();

        // Gdy: Pobieramy dane wielokrotnie
        String id2 = seans.dajId();
        String data2 = seans.dajDate();
        IFilm film2 = seans.dajFilm();

        // Wtedy: Dane powinny pozostać niezmienione
        assertSame(originalId, id2, "ID nie powinno się zmienić");
        assertSame(originalData, data2, "Data nie powinna się zmienić");
        assertSame(originalFilm, film2, "Film nie powinien się zmienić");
    }
}

\end{lstlisting}

\newpage

\subsubsection{model.TestDAOSeansy}
Plik: \texttt{src/test/java/model/TestDAOSeansy.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy DAO - operacje związane z seansami.
 * Testuje dodawanie, wyszukiwanie i usuwanie seansów.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Encja (model)
 * Zadanie: 1 (testy bez mockowania)
 */
@DisplayName("Testy klasy DAO - operacje seansów")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("repertuar")
class TestDAOSeansy {

    private DAO dao;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów DAO - operacje seansów");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie nowego DAO przed każdym testem
        dao = new DAO();
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów DAO - operacje seansów");
    }

    // ========== TESTY DODAWANIA SEANSÓW ==========

    @Test
    @Order(1)
    @DisplayName("Test dodawania seansu i generowania ID")
    void testDodajSeansGenerujeId() {
        // Jeśli: Dane seansu do zapisania (format: idFilmu;data;sala;miejsca)
        String daneSeansu = "F1;2024-12-20 18:00;Sala1;100";

        // Gdy: Dodajemy seans do DAO
        String id = dao.dodajSeans(daneSeansu);

        // Wtedy: ID powinno być wygenerowane
        assertNotNull(id, "ID nie powinno być null");
        assertTrue(id.startsWith("S"), "ID powinno zaczynać się od S");
    }

    @Test
    @Order(2)
    @DisplayName("Test że kolejne seanse mają unikalne ID")
    void testDodajSeanseUnikalneldId() {
        // Jeśli: Dane kilku seansów
        String seans1 = "F1;2024-12-20 18:00;Sala1;100";
        String seans2 = "F1;2024-12-20 21:00;Sala2;80";
        String seans3 = "F2;2024-12-21 19:00;Sala1;100";

        // Gdy: Dodajemy seanse kolejno
        String id1 = dao.dodajSeans(seans1);
        String id2 = dao.dodajSeans(seans2);
        String id3 = dao.dodajSeans(seans3);

        // Wtedy: Wszystkie ID powinny być unikalne
        assertNotEquals(id1, id2, "ID pierwszego i drugiego seansu powinny być różne");
        assertNotEquals(id2, id3, "ID drugiego i trzeciego seansu powinny być różne");
        assertNotEquals(id1, id3, "ID pierwszego i trzeciego seansu powinny być różne");
    }

    // ========== TESTY WYSZUKIWANIA SEANSÓW ==========

    @Test
    @Order(3)
    @DisplayName("Test znajdowania seansu po ID")
    void testZnajdzSeans() {
        // Jeśli: Seans został dodany do DAO
        String daneSeansu = "F1;2024-12-20 18:00;Sala1;100";
        String id = dao.dodajSeans(daneSeansu);

        // Gdy: Szukamy seansu po ID
        String znalezionySeans = dao.znajdzSeans(id);

        // Wtedy: Powinniśmy znaleźć ten sam seans
        assertNotNull(znalezionySeans, "Seans powinien zostać znaleziony");
        assertEquals(daneSeansu, znalezionySeans, "Dane seansu powinny być identyczne");
    }

    @Test
    @Order(4)
    @DisplayName("Test szukania nieistniejącego seansu")
    void testZnajdzSeansNieistniejacy() {
        // Jeśli: DAO jest puste lub seans nie istnieje

        // Gdy: Szukamy nieistniejącego seansu
        String znalezionySeans = dao.znajdzSeans("S999");

        // Wtedy: Powinniśmy otrzymać null
        assertNull(znalezionySeans, "Nieistniejący seans powinien zwrócić null");
    }

    @Test
    @Order(5)
    @DisplayName("Test znajdowania seansów dla filmu")
    void testZnajdzSeansyFilmu() {
        // Jeśli: Dodano kilka seansów dla tego samego filmu
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala1;100");

        // Gdy: Szukamy seansów dla filmu F1
        String[] seansyF1 = dao.znajdzSeansyFilmu("F1");

        // Wtedy: Powinny być 2 seanse dla filmu F1
        assertNotNull(seansyF1, "Tablica seansów nie powinna być null");
        assertEquals(2, seansyF1.length, "Powinny być 2 seanse dla filmu F1");
    }

    @Test
    @Order(6)
    @DisplayName("Test znajdowania seansów dla filmu który nie ma seansów")
    void testZnajdzSeansyFilmuBezSeansow() {
        // Jeśli: Dodano seanse dla filmu F1, ale nie dla F99
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");

        // Gdy: Szukamy seansów dla filmu F99
        String[] seansyF99 = dao.znajdzSeansyFilmu("F99");

        // Wtedy: Tablica powinna być pusta
        assertNotNull(seansyF99, "Tablica nie powinna być null");
        assertEquals(0, seansyF99.length, "Tablica powinna być pusta dla filmu bez seansów");
    }

    @Test
    @Order(7)
    @DisplayName("Test że znajdzSeansyFilmu zwraca poprawne ID seansów")
    void testZnajdzSeansyFilmuPoprawneId() {
        // Jeśli: Dodajemy seanse i zapisujemy ich ID
        String id1 = dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        String id2 = dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala1;100"); // inny film

        // Gdy: Szukamy seansów dla filmu F1
        String[] seansyF1 = dao.znajdzSeansyFilmu("F1");

        // Wtedy: Zwrócone ID powinny odpowiadać dodanym seansom
        assertEquals(2, seansyF1.length, "Powinny być 2 seanse");

        // Sprawdzamy czy oba ID są w tablicy
        boolean zawieraId1 = false;
        boolean zawieraId2 = false;
        for (String id : seansyF1) {
            if (id.equals(id1))
                zawieraId1 = true;
            if (id.equals(id2))
                zawieraId2 = true;
        }
        assertTrue(zawieraId1, "Tablica powinna zawierać ID pierwszego seansu");
        assertTrue(zawieraId2, "Tablica powinna zawierać ID drugiego seansu");
    }

    // ========== TESTY USUWANIA SEANSÓW ==========

    @Test
    @Order(8)
    @DisplayName("Test usuwania seansu")
    void testUsunSeans() {
        // Jeśli: Seans został dodany
        String id = dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        assertNotNull(dao.znajdzSeans(id), "Seans powinien istnieć przed usunięciem");

        // Gdy: Usuwamy seans
        dao.usunSeans(id);

        // Wtedy: Seans nie powinien być już dostępny
        assertNull(dao.znajdzSeans(id), "Seans nie powinien istnieć po usunięciu");
    }

    @Test
    @Order(9)
    @DisplayName("Test że usunięcie seansu nie wpływa na inne seanse")
    void testUsunSeansNieWplywaNaInne() {
        // Jeśli: Dodano kilka seansów
        String id1 = dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        String id2 = dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Usuwamy pierwszy seans
        dao.usunSeans(id1);

        // Wtedy: Drugi seans powinien nadal istnieć
        assertNull(dao.znajdzSeans(id1), "Usunięty seans nie powinien istnieć");
        assertNotNull(dao.znajdzSeans(id2), "Inny seans powinien nadal istnieć");
    }

    // ========== TESTY PARAMETRYZOWANE - @CsvSource ==========

    @ParameterizedTest
    @Order(10)
    @DisplayName("Test dodawania seansów z różnymi danymi - @CsvSource")
    @CsvSource({
            "F1, 2024-12-20 18:00, Sala1, 100",
            "F2, 2024-12-21 20:30, Sala2, 150",
            "F3, 2024-12-22 15:00, SalaVIP, 50",
            "F4, 2024-12-23 21:00, Sala3, 200"
    })
    void testDodajSeansParametryzowany(String idFilmu, String data, String sala, int miejsca) {
        // Jeśli: Dane seansu z parametrów
        String daneSeansu = idFilmu + ";" + data + ";" + sala + ";" + miejsca;

        // Gdy: Dodajemy seans
        String id = dao.dodajSeans(daneSeansu);

        // Wtedy: Seans powinien być dodany i możliwy do znalezienia
        assertNotNull(id, "ID nie powinno być null");
        String znaleziony = dao.znajdzSeans(id);
        assertNotNull(znaleziony, "Seans powinien być znaleziony");
        assertEquals(daneSeansu, znaleziony, "Dane seansu powinny być identyczne");
    }

    @ParameterizedTest
    @Order(11)
    @DisplayName("Test znajdowania seansów dla różnych filmów - @CsvSource")
    @CsvSource({
            "F1, 3",
            "F2, 2",
            "F3, 1"
    })
    void testZnajdzSeansyDlaRoznychFilmow(String idFilmu, int oczekiwanaLiczba) {
        // Jeśli: Dodajemy seanse dla różnych filmów
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");
        dao.dodajSeans("F1;2024-12-21 18:00;Sala1;100");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala1;100");
        dao.dodajSeans("F2;2024-12-21 21:00;Sala2;80");
        dao.dodajSeans("F3;2024-12-22 20:00;Sala1;100");

        // Gdy: Szukamy seansów dla określonego filmu
        String[] seanse = dao.znajdzSeansyFilmu(idFilmu);

        // Wtedy: Liczba seansów powinna być zgodna z oczekiwaną
        assertEquals(oczekiwanaLiczba, seanse.length,
                "Film " + idFilmu + " powinien mieć " + oczekiwanaLiczba + " seansów");
    }

    // ========== TESTY PARAMETRYZOWANE - @ValueSource ==========

    @ParameterizedTest
    @Order(12)
    @DisplayName("Test dodawania seansów z różnymi ID filmów - @ValueSource")
    @ValueSource(strings = { "F1", "F10", "F100", "F999", "FILM001" })
    void testDodajSeansRozneIdFilmow(String idFilmu) {
        // Jeśli: Różne ID filmów
        String daneSeansu = idFilmu + ";2024-12-25 18:00;Sala1;100";

        // Gdy: Dodajemy seans
        String id = dao.dodajSeans(daneSeansu);

        // Wtedy: Seans powinien być dodany
        assertNotNull(id, "ID seansu nie powinno być null");

        // I powinien być znajdowany przez znajdzSeansyFilmu
        String[] seanse = dao.znajdzSeansyFilmu(idFilmu);
        assertEquals(1, seanse.length, "Powinien być 1 seans dla filmu " + idFilmu);
    }

    @ParameterizedTest
    @Order(13)
    @DisplayName("Test dodawania seansów z różną liczbą miejsc - @ValueSource")
    @ValueSource(ints = { 20, 50, 100, 150, 200, 500 })
    void testDodajSeansRoznaLiczbaMiejsc(int liczbaMiejsc) {
        // Jeśli: Różne liczby miejsc
        String daneSeansu = "F1;2024-12-25 18:00;Sala1;" + liczbaMiejsc;

        // Gdy: Dodajemy seans
        String id = dao.dodajSeans(daneSeansu);

        // Wtedy: Seans powinien być zapisany z poprawną liczbą miejsc
        String znaleziony = dao.znajdzSeans(id);
        assertNotNull(znaleziony, "Seans powinien zostać znaleziony");
        assertTrue(znaleziony.contains(String.valueOf(liczbaMiejsc)),
                "Dane seansu powinny zawierać liczbę miejsc");
    }

    // ========== TESTY INTEGRALNOŚCI DANYCH ==========

    @Test
    @Order(14)
    @DisplayName("Test że dane seansu są przechowywane bez modyfikacji")
    void testDaneSeansaBezModyfikacji() {
        // Jeśli: Oryginalne dane seansu
        String oryginalneDane = "F1;2024-12-20 18:00;Sala Główna;120";

        // Gdy: Dodajemy i pobieramy seans
        String id = dao.dodajSeans(oryginalneDane);
        String pobraneDane = dao.znajdzSeans(id);

        // Wtedy: Dane powinny być identyczne
        assertEquals(oryginalneDane, pobraneDane, "Dane nie powinny być modyfikowane");
    }

    @Test
    @Order(15)
    @DisplayName("Test wielokrotnego wyszukiwania tego samego seansu")
    void testWielokrotneWyszukiwanie() {
        // Jeśli: Seans został dodany
        String daneSeansu = "F1;2024-12-20 18:00;Sala1;100";
        String id = dao.dodajSeans(daneSeansu);

        // Gdy: Szukamy seansu wielokrotnie
        String wynik1 = dao.znajdzSeans(id);
        String wynik2 = dao.znajdzSeans(id);
        String wynik3 = dao.znajdzSeans(id);

        // Wtedy: Każde wyszukiwanie powinno zwrócić te same dane
        assertEquals(wynik1, wynik2, "Wyniki powinny być identyczne");
        assertEquals(wynik2, wynik3, "Wyniki powinny być identyczne");
        assertEquals(daneSeansu, wynik1, "Dane powinny odpowiadać oryginalnym");
    }
}

\end{lstlisting}

\newpage

\subsubsection{model.TestModelPobierzRepertuar}
Plik: \texttt{src/test/java/model/TestModelPobierzRepertuar.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy Model - operacja pobierania repertuaru.
 * Testuje metodę Model.pobierzRepertuar() bez mockowania (z prawdziwym DAO).
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Encja (model)
 * Zadanie: 1 (testy bez mockowania)
 */
@DisplayName("Testy klasy Model - pobieranie repertuaru")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("encja")
@Tag("repertuar")
class TestModelPobierzRepertuar {

    private Model model;
    private DAO dao;
    private Oferta oferta;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów Model - pobieranie repertuaru");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie systemu przed każdym testem
        dao = new DAO();
        oferta = new Oferta(dao);
        model = new Model(oferta, dao);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        model = null;
        oferta = null;
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów Model - pobieranie repertuaru");
    }

    // ========== TESTY POBIERANIA REPERTUARU Z SEANSAMI ==========

    @Test
    @Order(1)
    @DisplayName("Test pobierania repertuaru gdy są seanse dla filmu")
    void testPobierzRepertuarZSeansami() {
        // Jeśli: Dodano seanse dla filmu F1
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Pobieramy repertuar dla filmu F1
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać informacje o seansach
        assertNotNull(repertuar, "Repertuar nie powinien być null");
        assertFalse(repertuar.isEmpty(), "Repertuar nie powinien być pusty");
        assertTrue(repertuar.contains("Repertuar"), "Repertuar powinien zawierać nagłówek");
        assertTrue(repertuar.contains("Seans"), "Repertuar powinien zawierać informacje o seansach");
    }

    @Test
    @Order(2)
    @DisplayName("Test pobierania repertuaru gdy brak seansów dla filmu")
    void testPobierzRepertuarBezSeansow() {
        // Jeśli: Nie dodano żadnych seansów dla filmu F99

        // Gdy: Pobieramy repertuar dla filmu F99
        String repertuar = model.pobierzRepertuar("F99");

        // Wtedy: Powinniśmy otrzymać komunikat o braku seansów
        assertNotNull(repertuar, "Repertuar nie powinien być null");
        assertTrue(repertuar.contains("Brak seansow"),
                "Repertuar powinien zawierać komunikat o braku seansów");
        assertTrue(repertuar.contains("F99"),
                "Komunikat powinien zawierać ID filmu");
    }

    @Test
    @Order(3)
    @DisplayName("Test że repertuar zawiera dane wszystkich seansów filmu")
    void testRepertuarZawieraDaneSeansow() {
        // Jeśli: Dodano seanse z konkretnymi danymi
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać dane wszystkich seansów
        assertTrue(repertuar.contains("2024-12-20 18:00"),
                "Repertuar powinien zawierać datę pierwszego seansu");
        assertTrue(repertuar.contains("2024-12-20 21:00"),
                "Repertuar powinien zawierać datę drugiego seansu");
        assertTrue(repertuar.contains("Sala1"),
                "Repertuar powinien zawierać salę pierwszego seansu");
        assertTrue(repertuar.contains("Sala2"),
                "Repertuar powinien zawierać salę drugiego seansu");
    }

    @Test
    @Order(4)
    @DisplayName("Test formatu repertuaru")
    void testFormatRepertuaru() {
        // Jeśli: Dodano seans
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien mieć odpowiedni format
        assertTrue(repertuar.startsWith("Repertuar dla filmu"),
                "Repertuar powinien zaczynać się od nagłówka");
        assertTrue(repertuar.contains("F1"),
                "Repertuar powinien zawierać ID filmu");
        assertTrue(repertuar.contains("- Seans:"),
                "Repertuar powinien formatować seanse z myślnikiem");
    }

    @Test
    @Order(5)
    @DisplayName("Test że repertuar nie zawiera seansów innych filmów")
    void testRepertuarNieZawieraInnychFilmow() {
        // Jeśli: Dodano seanse dla różnych filmów
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala2;80");
        dao.dodajSeans("F3;2024-12-22 20:00;Sala3;120");

        // Gdy: Pobieramy repertuar dla filmu F1
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać tylko seanse F1
        assertTrue(repertuar.contains("2024-12-20 18:00"),
                "Repertuar powinien zawierać seans F1");
        assertFalse(repertuar.contains("2024-12-21 19:00"),
                "Repertuar nie powinien zawierać seansu F2");
        assertFalse(repertuar.contains("2024-12-22 20:00"),
                "Repertuar nie powinien zawierać seansu F3");
    }

    // ========== TESTY WIELU SEANSÓW ==========

    @Test
    @Order(6)
    @DisplayName("Test pobierania repertuaru z wieloma seansami")
    void testPobierzRepertuarWieleSeansow() {
        // Jeśli: Dodano 5 seansów dla tego samego filmu
        dao.dodajSeans("F1;2024-12-20 10:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 13:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 16:00;Sala2;80");
        dao.dodajSeans("F1;2024-12-20 19:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 22:00;Sala2;80");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Wszystkie seanse powinny być wymienione
        assertNotNull(repertuar);
        // Liczymy wystąpienia "Seans" w repertuarze
        int liczbaSeansow = repertuar.split("Seans").length - 1;
        assertEquals(5, liczbaSeansow, "Powinno być 5 seansów w repertuarze");
    }

    @Test
    @Order(7)
    @DisplayName("Test pobierania repertuaru z pojedynczym seansem")
    void testPobierzRepertuarJedenSeans() {
        // Jeśli: Dodano tylko jeden seans
        dao.dodajSeans("F1;2024-12-25 20:00;SalaGłówna;150");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać dokładnie jeden seans
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Seans"), "Repertuar powinien zawierać seans");
        assertTrue(repertuar.contains("2024-12-25 20:00"),
                "Repertuar powinien zawierać datę seansu");
    }

    // ========== TESTY PARAMETRYZOWANE - @CsvSource ==========

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test pobierania repertuaru dla różnych filmów - @CsvSource")
    @CsvSource({
            "F1, 2024-12-20 18:00, Sala1",
            "F2, 2024-12-21 20:30, Sala2",
            "F3, 2024-12-22 15:00, SalaVIP"
    })
    void testPobierzRepertuarParametryzowany(String idFilmu, String data, String sala) {
        // Jeśli: Dodano seans z parametrów
        dao.dodajSeans(idFilmu + ";" + data + ";" + sala + ";100");

        // Gdy: Pobieramy repertuar dla danego filmu
        String repertuar = model.pobierzRepertuar(idFilmu);

        // Wtedy: Repertuar powinien zawierać dane seansu
        assertNotNull(repertuar, "Repertuar nie powinien być null");
        assertTrue(repertuar.contains(data), "Repertuar powinien zawierać datę");
        assertTrue(repertuar.contains(sala), "Repertuar powinien zawierać salę");
        assertFalse(repertuar.contains("Brak seansow"),
                "Nie powinno być komunikatu o braku seansów");
    }

    @ParameterizedTest
    @Order(9)
    @DisplayName("Test liczby seansów w repertuarze - @CsvSource")
    @CsvSource({
            "F1, 1",
            "F2, 2",
            "F3, 3"
    })
    void testLiczbaSeansowWRepertuarze(String idFilmu, int oczekiwanaLiczba) {
        // Jeśli: Dodajemy określoną liczbę seansów dla każdego filmu
        for (int i = 0; i < oczekiwanaLiczba; i++) {
            dao.dodajSeans(idFilmu + ";2024-12-20 " + (10 + i) + ":00;Sala1;100");
        }
        // Dodajemy też seanse innych filmów jako szum
        dao.dodajSeans("FX;2024-12-25 12:00;Sala1;100");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar(idFilmu);

        // Wtedy: Liczba seansów powinna być zgodna z oczekiwaną
        int liczbaSeansow = repertuar.split("Seans").length - 1;
        assertEquals(oczekiwanaLiczba, liczbaSeansow,
                "Repertuar dla " + idFilmu + " powinien mieć " + oczekiwanaLiczba + " seansów");
    }

    // ========== TESTY PARAMETRYZOWANE - @ValueSource ==========

    @ParameterizedTest
    @Order(10)
    @DisplayName("Test pobierania repertuaru dla filmów bez seansów - @ValueSource")
    @ValueSource(strings = { "F99", "F100", "NIEISTNIEJACY", "XYZ123" })
    void testPobierzRepertuarBrakSeansow(String idFilmu) {
        // Jeśli: Film nie ma żadnych seansów

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar(idFilmu);

        // Wtedy: Powinniśmy otrzymać komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Powinien być komunikat o braku seansów dla " + idFilmu);
        assertTrue(repertuar.contains(idFilmu),
                "Komunikat powinien zawierać ID filmu");
    }

    @ParameterizedTest
    @Order(11)
    @DisplayName("Test repertuaru z różnymi salami - @ValueSource")
    @ValueSource(strings = { "Sala1", "Sala2", "SalaVIP", "SalaIMAX", "Sala3D" })
    void testRepertuarRozneSale(String sala) {
        // Jeśli: Dodano seans w określonej sali
        dao.dodajSeans("F1;2024-12-25 18:00;" + sala + ";100");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać nazwę sali
        assertTrue(repertuar.contains(sala),
                "Repertuar powinien zawierać salę: " + sala);
    }

    // ========== TESTY EDGE CASES ==========

    @Test
    @Order(12)
    @DisplayName("Test pobierania repertuaru z pustym ID filmu")
    void testPobierzRepertuarPusteId() {
        // Jeśli: ID filmu jest puste

        // Gdy: Pobieramy repertuar z pustym ID
        String repertuar = model.pobierzRepertuar("");

        // Wtedy: Powinniśmy otrzymać komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Powinien być komunikat o braku seansów dla pustego ID");
    }

    @Test
    @Order(13)
    @DisplayName("Test że pobieranie repertuaru nie modyfikuje danych")
    void testPobierzRepertuarNieModyfikujeDanych() {
        // Jeśli: Dodano seans
        String daneSeansu = "F1;2024-12-20 18:00;Sala1;100";
        String seansId = dao.dodajSeans(daneSeansu);

        // Gdy: Pobieramy repertuar wielokrotnie
        model.pobierzRepertuar("F1");
        model.pobierzRepertuar("F1");
        model.pobierzRepertuar("F1");

        // Wtedy: Dane seansu powinny pozostać niezmienione
        String danePo = dao.znajdzSeans(seansId);
        assertEquals(daneSeansu, danePo, "Dane seansu nie powinny być modyfikowane");
    }

    @Test
    @Order(14)
    @DisplayName("Test spójności wielokrotnego pobierania repertuaru")
    void testSpojnoscWielokrotnePobieranie() {
        // Jeśli: Dodano seanse
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Pobieramy repertuar wielokrotnie
        String repertuar1 = model.pobierzRepertuar("F1");
        String repertuar2 = model.pobierzRepertuar("F1");
        String repertuar3 = model.pobierzRepertuar("F1");

        // Wtedy: Każde pobranie powinno zwrócić identyczny wynik
        assertEquals(repertuar1, repertuar2, "Repertuar powinien być spójny");
        assertEquals(repertuar2, repertuar3, "Repertuar powinien być spójny");
    }
}

\end{lstlisting}

\newpage

\subsubsection{controller.TestClientControllerPrzegladanieRepertuaru}
Plik: \texttt{src/test/java/controller/TestClientControllerPrzegladanieRepertuaru.java}

\begin{lstlisting}
package controller;

import model.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testy jednostkowe dla klasy ClientController - przeglądanie repertuaru.
 * Testuje metodę ClientController.przegladajRepertuar() bez mockowania.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Kontroli (controller)
 * Zadanie: 1 (testy bez mockowania)
 */
@DisplayName("Testy klasy ClientController - przeglądanie repertuaru")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Tag("kontroler")
@Tag("repertuar")
class TestClientControllerPrzegladanieRepertuaru {

    private ClientController clientController;
    private Model model;
    private DAO dao;
    private Oferta oferta;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów ClientController - przeglądanie repertuaru");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie pełnego systemu przed każdym testem
        dao = new DAO();
        oferta = new Oferta(dao);
        model = new Model(oferta, dao);
        clientController = new ClientController(model);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        clientController = null;
        model = null;
        oferta = null;
        dao = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów ClientController - przeglądanie repertuaru");
    }

    // ========== TESTY PRZEGLĄDANIA REPERTUARU ==========

    @Test
    @Order(1)
    @DisplayName("Test przeglądania repertuaru przez ClientController")
    void testPrzegladajRepertuar() {
        // Jeśli: Dodano seanse dla filmu
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar("F1");

        // Wtedy: Powinien otrzymać informacje o seansach
        assertNotNull(repertuar, "Repertuar nie powinien być null");
        assertFalse(repertuar.isEmpty(), "Repertuar nie powinien być pusty");
        assertTrue(repertuar.contains("Repertuar"), "Repertuar powinien zawierać nagłówek");
    }

    @Test
    @Order(2)
    @DisplayName("Test przeglądania repertuaru bez seansów")
    void testPrzegladajRepertuarBezSeansow() {
        // Jeśli: Film nie ma seansów

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar("F99");

        // Wtedy: Powinien otrzymać komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Powinien być komunikat o braku seansów");
    }

    @Test
    @Order(3)
    @DisplayName("Test że ClientController deleguje do Model")
    void testDelegacjaDoModel() {
        // Jeśli: Dodano seans z unikalnymi danymi
        dao.dodajSeans("F1;2024-12-25 20:00;SalaSpecjalna;200");

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar("F1");

        // Wtedy: Wynik powinien zawierać dane z DAO (przeszło przez Model)
        assertTrue(repertuar.contains("SalaSpecjalna"),
                "Repertuar powinien zawierać dane z DAO");
        assertTrue(repertuar.contains("2024-12-25 20:00"),
                "Repertuar powinien zawierać datę z DAO");
    }

    @Test
    @Order(4)
    @DisplayName("Test przeglądania repertuaru z wieloma seansami")
    void testPrzegladajRepertuarWieleSeansow() {
        // Jeśli: Dodano wiele seansów
        dao.dodajSeans("F1;2024-12-20 10:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 13:00;Sala1;100");
        dao.dodajSeans("F1;2024-12-20 16:00;Sala2;80");
        dao.dodajSeans("F1;2024-12-20 19:00;Sala1;100");

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar("F1");

        // Wtedy: Wszystkie seanse powinny być dostępne
        assertTrue(repertuar.contains("10:00"), "Repertuar powinien zawierać seans o 10:00");
        assertTrue(repertuar.contains("13:00"), "Repertuar powinien zawierać seans o 13:00");
        assertTrue(repertuar.contains("16:00"), "Repertuar powinien zawierać seans o 16:00");
        assertTrue(repertuar.contains("19:00"), "Repertuar powinien zawierać seans o 19:00");
    }

    @Test
    @Order(5)
    @DisplayName("Test że repertuar zawiera tylko seanse wybranego filmu")
    void testRepertuarTylkoWybranyFilm() {
        // Jeśli: Dodano seanse dla różnych filmów
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala2;80");
        dao.dodajSeans("F3;2024-12-22 20:00;Sala3;120");

        // Gdy: Klient przegląda repertuar dla F1
        String repertuar = clientController.przegladajRepertuar("F1");

        // Wtedy: Repertuar powinien zawierać tylko seanse F1
        assertTrue(repertuar.contains("2024-12-20 18:00"),
                "Repertuar powinien zawierać seans F1");
        assertFalse(repertuar.contains("2024-12-21 19:00"),
                "Repertuar nie powinien zawierać seansu F2");
        assertFalse(repertuar.contains("2024-12-22 20:00"),
                "Repertuar nie powinien zawierać seansu F3");
    }

    // ========== TESTY PEŁNEGO PRZEPŁYWU ==========

    @Test
    @Order(6)
    @DisplayName("Test pełnego przepływu - od kontrolera do DAO")
    void testPelnyPrzeplyw() {
        // Jeśli: Kompletne dane seansu
        String daneSeansu = "F1;2024-12-25 18:00;SalaGłówna;150";
        dao.dodajSeans(daneSeansu);

        // Gdy: Klient przegląda repertuar przez ClientController
        // (co wywołuje Model -> DAO)
        String repertuar = clientController.przegladajRepertuar("F1");

        // Wtedy: Cały przepływ powinien zakończyć się sukcesem
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Repertuar dla filmu F1"),
                "Repertuar powinien mieć poprawny nagłówek");
        assertTrue(repertuar.contains("SalaGłówna"),
                "Repertuar powinien zawierać dane seansu");
    }

    @Test
    @Order(7)
    @DisplayName("Test wielokrotnego przeglądania tego samego repertuaru")
    void testWielokrotnePrzegladanie() {
        // Jeśli: Dodano seanse
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");

        // Gdy: Klient przegląda repertuar wielokrotnie
        String repertuar1 = clientController.przegladajRepertuar("F1");
        String repertuar2 = clientController.przegladajRepertuar("F1");
        String repertuar3 = clientController.przegladajRepertuar("F1");

        // Wtedy: Każde przeglądanie powinno zwrócić identyczny wynik
        assertEquals(repertuar1, repertuar2, "Repertuar powinien być spójny");
        assertEquals(repertuar2, repertuar3, "Repertuar powinien być spójny");
    }

    @Test
    @Order(8)
    @DisplayName("Test przeglądania repertuaru różnych filmów sekwencyjnie")
    void testPrzegladanieRoznychFilmow() {
        // Jeśli: Dodano seanse dla różnych filmów
        dao.dodajSeans("F1;2024-12-20 18:00;Sala1;100");
        dao.dodajSeans("F2;2024-12-21 19:00;Sala2;80");
        dao.dodajSeans("F3;2024-12-22 20:00;Sala3;120");

        // Gdy: Klient przegląda repertuary kolejno
        String repertuarF1 = clientController.przegladajRepertuar("F1");
        String repertuarF2 = clientController.przegladajRepertuar("F2");
        String repertuarF3 = clientController.przegladajRepertuar("F3");

        // Wtedy: Każdy repertuar powinien być inny i zawierać właściwe dane
        assertNotEquals(repertuarF1, repertuarF2, "Repertuary powinny być różne");
        assertNotEquals(repertuarF2, repertuarF3, "Repertuary powinny być różne");
        assertTrue(repertuarF1.contains("F1"), "Repertuar F1 powinien zawierać ID F1");
        assertTrue(repertuarF2.contains("F2"), "Repertuar F2 powinien zawierać ID F2");
        assertTrue(repertuarF3.contains("F3"), "Repertuar F3 powinien zawierać ID F3");
    }

    // ========== TESTY PARAMETRYZOWANE - @CsvSource ==========

    @ParameterizedTest
    @Order(9)
    @DisplayName("Test przeglądania repertuaru z różnymi danymi - @CsvSource")
    @CsvSource({
            "F1, 2024-12-20 18:00, Sala1, 100",
            "F2, 2024-12-21 20:30, Sala2, 150",
            "F3, 2024-12-22 15:00, SalaVIP, 50",
            "F4, 2024-12-23 21:00, IMAX, 200"
    })
    void testPrzegladajRepertuarParametryzowany(String idFilmu, String data,
            String sala, int miejsca) {
        // Jeśli: Dodano seans z parametrów
        dao.dodajSeans(idFilmu + ";" + data + ";" + sala + ";" + miejsca);

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar(idFilmu);

        // Wtedy: Repertuar powinien zawierać dane seansu
        assertNotNull(repertuar);
        assertTrue(repertuar.contains(data),
                "Repertuar powinien zawierać datę: " + data);
        assertTrue(repertuar.contains(sala),
                "Repertuar powinien zawierać salę: " + sala);
    }

    @ParameterizedTest
    @Order(10)
    @DisplayName("Test przeglądania repertuaru dla różnych filmów - @CsvSource")
    @CsvSource({
            "FILM001, 3",
            "FILM002, 2",
            "FILM003, 1"
    })
    void testLiczbaSeansowWRepertuarze(String idFilmu, int liczbaSeansow) {
        // Jeśli: Dodajemy określoną liczbę seansów
        for (int i = 0; i < liczbaSeansow; i++) {
            dao.dodajSeans(idFilmu + ";2024-12-20 " + (10 + i * 3) + ":00;Sala" + (i + 1) + ";100");
        }

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar(idFilmu);

        // Wtedy: Liczba seansów powinna być prawidłowa
        int licznik = repertuar.split("Seans").length - 1;
        assertEquals(liczbaSeansow, licznik,
                "Powinno być " + liczbaSeansow + " seansów dla " + idFilmu);
    }

    // ========== TESTY PARAMETRYZOWANE - @ValueSource ==========

    @ParameterizedTest
    @Order(11)
    @DisplayName("Test przeglądania repertuaru dla filmów bez seansów - @ValueSource")
    @ValueSource(strings = { "NIEISTNIEJACY", "F999", "XYZ", "TEST123" })
    void testPrzegladajRepertuarBrakSeansow(String idFilmu) {
        // Jeśli: Film nie ma żadnych seansów

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar(idFilmu);

        // Wtedy: Powinien otrzymać komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Powinien być komunikat o braku seansów dla " + idFilmu);
    }

    @ParameterizedTest
    @Order(12)
    @DisplayName("Test przeglądania repertuaru z różnymi ID filmów - @ValueSource")
    @ValueSource(strings = { "F1", "F10", "FILM", "MOVIE_2024" })
    void testPrzegladajRepertuarRozneIdFilmow(String idFilmu) {
        // Jeśli: Dodano seans dla filmu
        dao.dodajSeans(idFilmu + ";2024-12-25 18:00;Sala1;100");

        // Gdy: Klient przegląda repertuar
        String repertuar = clientController.przegladajRepertuar(idFilmu);

        // Wtedy: Repertuar powinien zawierać dane seansu
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Repertuar dla filmu " + idFilmu),
                "Repertuar powinien zawierać nagłówek z ID filmu");
        assertFalse(repertuar.contains("Brak seansow"),
                "Nie powinno być komunikatu o braku seansów");
    }

    // ========== TESTY EDGE CASES ==========

    @Test
    @Order(13)
    @DisplayName("Test przeglądania repertuaru z pustym ID")
    void testPrzegladajRepertuarPusteId() {
        // Jeśli: ID filmu jest puste

        // Gdy: Klient przegląda repertuar z pustym ID
        String repertuar = clientController.przegladajRepertuar("");

        // Wtedy: Powinien otrzymać komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Powinien być komunikat o braku seansów");
    }

    @Test
    @Order(14)
    @DisplayName("Test że ClientController nie modyfikuje danych")
    void testNieModyfikujeDanych() {
        // Jeśli: Dodano seans
        String daneSeansu = "F1;2024-12-20 18:00;Sala1;100";
        String seansId = dao.dodajSeans(daneSeansu);

        // Gdy: Klient przegląda repertuar wielokrotnie
        clientController.przegladajRepertuar("F1");
        clientController.przegladajRepertuar("F1");

        // Wtedy: Dane seansu powinny pozostać niezmienione
        String danePo = dao.znajdzSeans(seansId);
        assertEquals(daneSeansu, danePo,
                "Dane seansu nie powinny być modyfikowane przez przeglądanie");
    }
}

\end{lstlisting}

\newpage


\section{Zadanie 2: Testy jednostkowe z mockowaniem (Mockito)}

\subsection{Przypadek użycia: Dodanie filmu do oferty}

W tym zadaniu testujemy klasy z symulacją zależności (z mockowaniem Mockito).

\subsubsection{model.TestModelDodawanieFilmuMock}
Plik: \texttt{src/test/java/model/TestModelDodawanieFilmuMock.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testy jednostkowe dla klasy Model - operacja dodawania filmu z użyciem
 * mockowania.
 * Testuje metodę Model.dodajFilm() z symulacją zależności (IDAO).
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Warstwa: Encja (model)
 * Zadanie: 2 (testy z mockowaniem)
 * 
 * Ref. z instrukcji: "Symulować należy te fragmenty kodu (obiekty, operacje),
 * od których zależy testowana operacja"
 */
@DisplayName("Testy klasy Model - dodawanie filmu z mockowaniem")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
@Tag("encja")
@Tag("dodawanie")
@Tag("mock")
class TestModelDodawanieFilmuMock {

    /**
     * Mock obiektu DAO - symulacja warstwy dostępu do danych.
     * Ref. z instrukcji: "operacja mock() lub adnotacja @Mock"
     */
    @Mock
    private IDAO mockDao;

    /**
     * Mock obiektu Oferta (nie używany bezpośrednio w dodajFilm,
     * ale wymagany przez konstruktor Model)
     */
    @Mock
    private Oferta mockOferta;

    /**
     * Testowany obiekt Model z wstrzykniętymi symulacjami.
     * Ref. z instrukcji: "adnotacja @InjectMocks w Mockito"
     */
    @InjectMocks
    private Model model;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów Model z mockowaniem");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Inicjalizacja mocków - wykonywana automatycznie przez
        // @ExtendWith(MockitoExtension.class)
        // MockitoAnnotations.openMocks(this) - alternatywa dla @ExtendWith
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście - resetowanie mocków
        reset(mockDao, mockOferta);
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów Model z mockowaniem");
    }

    // ========== TESTY Z WHEN().THENRETURN() ==========

    @Test
    @Order(1)
    @DisplayName("Test dodawania filmu - sukces z mockowanym DAO")
    void testDodajFilmSukces() {
        // Jeśli: Mock DAO zwraca ID filmu po dodaniu
        // Ref. z instrukcji: "when().thenReturn() w Mockito"
        String daneFilmu = "F001;Matrix;Cyberpunk thriller;136;SciFi;28.5";
        when(mockDao.dodajFilm(anyString())).thenReturn("F001");

        // Gdy: Wywołujemy dodajFilm na modelu
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Weryfikujemy wynik i użycie mocka
        assertNotNull(wynik, "Wynik nie powinien być null");
        assertTrue(wynik.contains("pomyslnie"), "Wynik powinien zawierać 'pomyslnie'");
        assertTrue(wynik.contains("F001"), "Wynik powinien zawierać ID filmu");

        // Ref. z instrukcji: "verify(), times()"
        verify(mockDao, times(1)).dodajFilm(anyString());
    }

    @Test
    @Order(2)
    @DisplayName("Test że DAO.dodajFilm jest wywoływane dokładnie raz")
    void testDodajFilmWywolanieDaoJednorazowe() {
        // Jeśli: Przygotowanie mocka
        String daneFilmu = "F002;Avatar;Fantasy;162;SciFi;35.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("F002");

        // Gdy: Wywołujemy dodajFilm
        model.dodajFilm(daneFilmu);

        // Wtedy: DAO.dodajFilm powinno być wywołane dokładnie raz
        // Ref. z instrukcji: "verify(), times()"
        verify(mockDao, times(1)).dodajFilm(anyString());
        verify(mockDao, never()).edytujFilm(anyString());
        verify(mockDao, never()).usunFilm(anyString());
    }

    @Test
    @Order(3)
    @DisplayName("Test że DAO.dodajWpisDoLogu jest wywoływane po dodaniu filmu")
    void testDodajFilmLogowanie() {
        // Jeśli: Mock DAO zwraca ID
        String daneFilmu = "F003;Inception;Thriller;148;Thriller;32.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("F003");
        // doNothing() dla metod void - ref. z instrukcji: "doNothing().when()"
        doNothing().when(mockDao).dodajWpisDoLogu(anyString());

        // Gdy: Wywołujemy dodajFilm
        model.dodajFilm(daneFilmu);

        // Wtedy: Logowanie powinno nastąpić
        verify(mockDao).dodajWpisDoLogu(contains("F003"));
        verify(mockDao, atLeastOnce()).dodajWpisDoLogu(anyString());
    }

    // ========== TESTY KOLEJNOŚCI WYWOŁAŃ - InOrder ==========

    @Test
    @Order(4)
    @DisplayName("Test kolejności wywołań: najpierw dodajFilm, potem log")
    void testKolejnoscWywolanDAO() {
        // Jeśli: Określamy kolejność wywołań
        // Ref. z instrukcji: "klasa InOrder w Mockito"
        String daneFilmu = "F004;Titanic;Romans;195;Dramat;25.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("F004");
        InOrder inOrder = inOrder(mockDao);

        // Gdy: Wywołujemy dodajFilm
        model.dodajFilm(daneFilmu);

        // Wtedy: Najpierw dodajFilm, potem log
        inOrder.verify(mockDao).dodajFilm(anyString());
        inOrder.verify(mockDao).dodajWpisDoLogu(anyString());
    }

    // ========== TESTY Z WHEN().THENTHROW() ==========

    @Test
    @Order(5)
    @DisplayName("Test obsługi wyjątku z DAO.dodajFilm")
    void testDodajFilmWyjatekDAO() {
        // Jeśli: Mock DAO rzuca wyjątek
        // Ref. z instrukcji: "when().thenThrow() w Mockito"
        String daneFilmu = "F005;Error;Opis;120;Gatunek;20.0";
        when(mockDao.dodajFilm(anyString()))
                .thenThrow(new RuntimeException("Błąd zapisu do bazy danych"));

        // Gdy/Wtedy: Operacja powinna propagować wyjątek
        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> model.dodajFilm(daneFilmu),
                "Powinien wystąpić RuntimeException");

        assertTrue(exception.getMessage().contains("Błąd zapisu"),
                "Komunikat wyjątku powinien zawierać informację o błędzie");
    }

    // ========== TESTY WERYFIKACJI PARAMETRÓW ==========

    @Test
    @Order(6)
    @DisplayName("Test że dane filmu są przekazywane do DAO w poprawnym formacie")
    void testFormatDanychPrzekzywanychDoDAO() {
        // Jeśli: Dane filmu
        String daneFilmu = "F006;TestFilm;TestOpis;100;Gatunek;20.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("F006");

        // Gdy: Wywołujemy dodajFilm
        model.dodajFilm(daneFilmu);

        // Wtedy: Weryfikujemy że dane zawierają kluczowe elementy
        ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
        verify(mockDao).dodajFilm(captor.capture());

        String przekazaneDane = captor.getValue();
        assertTrue(przekazaneDane.contains("F006"), "Dane powinny zawierać ID");
        assertTrue(przekazaneDane.contains("TestFilm"), "Dane powinny zawierać tytuł");
    }

    // ========== TESTY PARAMETRYZOWANE Z MOCKOWANIEM ==========

    @ParameterizedTest
    @Order(7)
    @DisplayName("Test dodawania różnych filmów - parametryzowany")
    @CsvSource({
            "F010, Parasite, Dramat, 132, Dramat, 28.0",
            "F011, Joker, Psychologiczny, 122, Thriller, 30.0",
            "F012, 1917, Wojenny, 119, Wojenny, 27.5"
    })
    void testDodajFilmParametryzowany(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Mock DAO zwraca odpowiednie ID
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;
        when(mockDao.dodajFilm(anyString())).thenReturn(id);

        // Gdy: Wywołujemy dodajFilm
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Film powinien być "dodany" z poprawnym ID
        assertNotNull(wynik);
        assertTrue(wynik.contains(id), "Wynik powinien zawierać ID: " + id);
        verify(mockDao).dodajFilm(contains(tytul));
    }

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test dodawania filmów z różnymi ID - @ValueSource")
    @ValueSource(strings = { "F100", "F200", "F300", "F400" })
    void testDodajFilmRozneId(String id) {
        // Jeśli: Mock DAO zwraca określone ID
        String daneFilmu = id + ";Film;Opis;120;Gatunek;25.0";
        when(mockDao.dodajFilm(anyString())).thenReturn(id);

        // Gdy: Wywołujemy dodajFilm
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Wynik powinien zawierać to ID
        assertTrue(wynik.contains(id));
        verify(mockDao, atMostOnce()).dodajFilm(anyString());
    }

    // ========== TESTY WERYFIKACJI LICZBY WYWOŁAŃ ==========

    @Test
    @Order(9)
    @DisplayName("Test że dodanie wielu filmów wywołuje DAO odpowiednią liczbę razy")
    void testDodanieWieluFilmow() {
        // Jeśli: Mock DAO zwraca różne ID
        when(mockDao.dodajFilm(anyString()))
                .thenReturn("F001")
                .thenReturn("F002")
                .thenReturn("F003");

        // Gdy: Dodajemy 3 filmy
        model.dodajFilm("F001;Film1;Opis1;90;Gatunek;20.0");
        model.dodajFilm("F002;Film2;Opis2;100;Gatunek;25.0");
        model.dodajFilm("F003;Film3;Opis3;110;Gatunek;30.0");

        // Wtedy: DAO.dodajFilm powinno być wywołane 3 razy
        // Ref. z instrukcji: "atLeast(), times()"
        verify(mockDao, times(3)).dodajFilm(anyString());
        verify(mockDao, atLeast(3)).dodajWpisDoLogu(anyString());
    }

    @Test
    @Order(10)
    @DisplayName("Test że atMost weryfikuje maksymalną liczbę wywołań")
    void testAtMostWywolania() {
        // Jeśli: Mock DAO
        when(mockDao.dodajFilm(anyString())).thenReturn("FX");

        // Gdy: Dodajemy 2 filmy
        model.dodajFilm("FX;Film1;Opis;90;Gatunek;20.0");
        model.dodajFilm("FX;Film2;Opis;100;Gatunek;25.0");

        // Wtedy: Weryfikacja atMost
        // Ref. z instrukcji: "atMost(), atMostOnce()"
        verify(mockDao, atMost(5)).dodajFilm(anyString());
        verify(mockDao, atMost(5)).dodajWpisDoLogu(anyString());
    }

    // ========== TEST DORETURN().WHEN() DLA VOID ==========

    @Test
    @Order(11)
    @DisplayName("Test użycia doNothing().when() dla metody void")
    void testDoNothingDlaMetodyVoid() {
        // Jeśli: Konfigurujemy mock dla metody void
        // Ref. z instrukcji: "doNothing().when() w Mockito"
        String daneFilmu = "FV;VoidTest;Opis;90;Gatunek;15.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("FV");
        doNothing().when(mockDao).dodajWpisDoLogu(anyString());

        // Gdy: Wywołujemy dodajFilm
        String wynik = model.dodajFilm(daneFilmu);

        // Wtedy: Operacja powinna się zakończyć sukcesem
        assertNotNull(wynik);
        verify(mockDao).dodajWpisDoLogu(anyString());
    }

    // ========== TEST DOTHROW().WHEN() DLA VOID ==========

    @Test
    @Order(12)
    @DisplayName("Test użycia doThrow().when() dla metody void")
    void testDoThrowDlaMetodyVoid() {
        // Jeśli: Mock dla metody void rzuca wyjątek
        // Ref. z instrukcji: "doThrow().when() w Mockito"
        String daneFilmu = "FE;ErrorLog;Opis;90;Gatunek;15.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("FE");
        doThrow(new RuntimeException("Błąd logowania"))
                .when(mockDao).dodajWpisDoLogu(anyString());

        // Gdy/Wtedy: Wyjątek powinien być propagowany
        assertThrows(RuntimeException.class,
                () -> model.dodajFilm(daneFilmu),
                "Wyjątek z logowania powinien być propagowany");
    }

    // ========== TEST NEVER() ==========

    @Test
    @Order(13)
    @DisplayName("Test że metody niepowiązane nie są wywoływane")
    void testNeverWywolania() {
        // Jeśli: Mock DAO
        String daneFilmu = "FN;NeverTest;Opis;90;Gatunek;15.0";
        when(mockDao.dodajFilm(anyString())).thenReturn("FN");

        // Gdy: Wywołujemy dodajFilm
        model.dodajFilm(daneFilmu);

        // Wtedy: Metody edycji i usuwania nie powinny być wywołane
        // Ref. z instrukcji: "never() w Mockito"
        verify(mockDao, never()).edytujFilm(anyString());
        verify(mockDao, never()).usunFilm(anyString());
        verify(mockDao, never()).znajdzFilm(anyString());
    }
}

\end{lstlisting}

\newpage

\subsubsection{controller.TestAdminControllerDodawanieFilmuMock}
Plik: \texttt{src/test/java/controller/TestAdminControllerDodawanieFilmuMock.java}

\begin{lstlisting}
package controller;

import model.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testy jednostkowe dla klasy AdminController - operacja dodawania filmu z
 * użyciem mockowania.
 * Testuje metodę AdminController.dodajFilm() z symulacją zależności (IModel).
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Warstwa: Kontroli (controller)
 * Zadanie: 2 (testy z mockowaniem)
 * 
 * Ref. z instrukcji: "Testy klas modelujących elementarne usługi biznesowe
 * (np. krok realizacji przypadku użycia) w warstwie kontroli"
 */
@DisplayName("Testy klasy AdminController - dodawanie filmu z mockowaniem")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
@Tag("kontroler")
@Tag("dodawanie")
@Tag("mock")
class TestAdminControllerDodawanieFilmuMock {

    /**
     * Mock obiektu Model - symulacja warstwy modelu.
     * Ref. z instrukcji: "operacja mock() lub adnotacja @Mock"
     */
    @Mock
    private IModel mockModel;

    /**
     * Testowany kontroler - NIE używamy @InjectMocks bo AdminController
     * tworzy wewnętrznie EdytowanieOfertyKina, więc tworzymy go ręcznie.
     */
    private AdminController adminController;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów AdminController z mockowaniem");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie kontrolera z mockowanym modelem
        adminController = new AdminController(mockModel);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        reset(mockModel);
        adminController = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów AdminController z mockowaniem");
    }

    // ========== TESTY DELEGACJI DO MODELU ==========

    @Test
    @Order(1)
    @DisplayName("Test że AdminController deleguje do Model.dodajFilm()")
    void testDelegacjaDoModelu() {
        // Jeśli: Mock Model zwraca sukces
        // Ref. z instrukcji: "when().thenReturn()"
        String daneFilmu = "F001;Matrix;Cyberpunk;136;SciFi;28.5";
        when(mockModel.dodajFilm(anyString())).thenReturn("Film dodany pomyslnie. ID: F001");

        // Gdy: Wywołujemy dodajFilm przez kontroler
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Model powinien być wywołany
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Ref. z instrukcji: "verify(), times()"
        verify(mockModel, times(1)).dodajFilm(anyString());
    }

    @Test
    @Order(2)
    @DisplayName("Test że wynik z modelu jest zwracany bez modyfikacji")
    void testZwracanieWynikuBezModyfikacji() {
        // Jeśli: Model zwraca określony komunikat
        String oczekiwanyWynik = "Film dodany pomyslnie. ID: F001";
        when(mockModel.dodajFilm(anyString())).thenReturn(oczekiwanyWynik);

        // Gdy: Wywołujemy przez kontroler
        String wynik = adminController.dodajFilm("F001;Film;Opis;120;Gatunek;20.0");

        // Wtedy: Wynik powinien być identyczny
        assertEquals(oczekiwanyWynik, wynik, "Wynik powinien być identyczny z tym z modelu");
    }

    @Test
    @Order(3)
    @DisplayName("Test że dane są przekazywane do modelu")
    void testPrzekazywanieDanych() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;TestFilm;TestOpis;100;TestGatunek;25.0";
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");

        // Gdy: Wywołujemy kontroler
        adminController.dodajFilm(daneFilmu);

        // Wtedy: Dane powinny być przekazane do modelu (choć przez strategię)
        // Model.dodajFilm powinien być wywołany
        verify(mockModel).dodajFilm(anyString());
    }

    // ========== TESTY OBSŁUGI BŁĘDÓW ==========

    @Test
    @Order(4)
    @DisplayName("Test obsługi wyjątku z modelu")
    void testWyjatekZModelu() {
        // Jeśli: Model rzuca wyjątek
        // Ref. z instrukcji: "when().thenThrow()"
        when(mockModel.dodajFilm(anyString()))
                .thenThrow(new RuntimeException("Błąd w modelu"));

        // Gdy/Wtedy: Kontroler powinien propagować wyjątek
        RuntimeException ex = assertThrows(RuntimeException.class,
                () -> adminController.dodajFilm("F001;Film;Opis;100;Gatunek;20.0"));

        assertTrue(ex.getMessage().contains("Błąd w modelu"));
    }

    @Test
    @Order(5)
    @DisplayName("Test że wyjątek nie powoduje wielokrotnych wywołań")
    void testWyjatekNiePowodujePonownegoWywolania() {
        // Jeśli: Model rzuca wyjątek
        when(mockModel.dodajFilm(anyString()))
                .thenThrow(new RuntimeException("Error"));

        // Gdy: Próba dodania filmu
        try {
            adminController.dodajFilm("FX;Film;Opis;100;Gatunek;20.0");
        } catch (RuntimeException e) {
            // Oczekiwany wyjątek
        }

        // Wtedy: Model powinien być wywołany tylko raz
        // Ref. z instrukcji: "atMostOnce()"
        verify(mockModel, atMostOnce()).dodajFilm(anyString());
    }

    // ========== TESTY KOLEJNOŚCI - InOrder ==========

    @Test
    @Order(6)
    @DisplayName("Test kolejności wywołań z InOrder")
    void testKolejnoscWywolan() {
        // Jeśli: Mock modelu
        // Ref. z instrukcji: "klasa InOrder w Mockito"
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");
        InOrder inOrder = inOrder(mockModel);

        // Gdy: Wywołujemy dodajFilm
        adminController.dodajFilm("F001;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Model.dodajFilm powinien być wywołany
        inOrder.verify(mockModel).dodajFilm(anyString());
    }

    // ========== TESTY WERYFIKACJI NEVER ==========

    @Test
    @Order(7)
    @DisplayName("Test że inne metody modelu nie są wywoływane")
    void testNieWywolywanieInnychMetod() {
        // Jeśli: Mock modelu
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");

        // Gdy: Wywołujemy dodajFilm
        adminController.dodajFilm("F001;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Inne metody nie powinny być wywołane
        // Ref. z instrukcji: "never()"
        verify(mockModel, never()).edytujFilm(anyString(), anyString());
        verify(mockModel, never()).usunFilm(anyString());
        verify(mockModel, never()).pobierzRepertuar(anyString());
    }

    // ========== TESTY PARAMETRYZOWANE ==========

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test dodawania różnych filmów - @CsvSource")
    @CsvSource({
            "F001, Matrix, SciFi, 136, SciFi, 28.0",
            "F002, Avatar, Fantasy, 162, SciFi, 35.0",
            "F003, Titanic, Romans, 195, Dramat, 25.0"
    })
    void testDodajFilmParametryzowany(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Mock zwraca sukces
        String expectedResult = "Film dodany pomyslnie. ID: " + id;
        when(mockModel.dodajFilm(anyString())).thenReturn(expectedResult);

        // Gdy: Wywołujemy z parametrami
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;
        String wynik = adminController.dodajFilm(daneFilmu);

        // Wtedy: Wynik powinien zawierać ID
        assertTrue(wynik.contains(id), "Wynik powinien zawierać ID: " + id);
        verify(mockModel).dodajFilm(anyString());
    }

    @ParameterizedTest
    @Order(9)
    @DisplayName("Test dodawania filmów z różnymi komunikatami - @ValueSource")
    @ValueSource(strings = {
            "Film dodany pomyslnie. ID: F001",
            "Sukces - film F002 został dodany",
            "OK"
    })
    void testRozneKomunikatyZwrotne(String komunikatZModelu) {
        // Jeśli: Model zwraca różne komunikaty
        when(mockModel.dodajFilm(anyString())).thenReturn(komunikatZModelu);

        // Gdy: Wywołujemy kontroler
        String wynik = adminController.dodajFilm("FX;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Komunikat powinien być przekazany bez zmian
        assertEquals(komunikatZModelu, wynik);
    }

    // ========== TESTY WIELOKROTNYCH WYWOŁAŃ ==========

    @Test
    @Order(10)
    @DisplayName("Test wielokrotnego dodawania filmów")
    void testWielokrotneDodawanieFilmow() {
        // Jeśli: Model zwraca różne odpowiedzi
        when(mockModel.dodajFilm(anyString()))
                .thenReturn("Film dodany. ID: F001")
                .thenReturn("Film dodany. ID: F002")
                .thenReturn("Film dodany. ID: F003");

        // Gdy: Dodajemy 3 filmy
        String wynik1 = adminController.dodajFilm("F001;Film1;Opis;100;Gatunek;20.0");
        String wynik2 = adminController.dodajFilm("F002;Film2;Opis;110;Gatunek;25.0");
        String wynik3 = adminController.dodajFilm("F003;Film3;Opis;120;Gatunek;30.0");

        // Wtedy: Każdy wynik powinien być inny
        assertTrue(wynik1.contains("F001"));
        assertTrue(wynik2.contains("F002"));
        assertTrue(wynik3.contains("F003"));

        // Ref. z instrukcji: "times(), atLeast()"
        verify(mockModel, times(3)).dodajFilm(anyString());
        verify(mockModel, atLeast(3)).dodajFilm(anyString());
    }

    @Test
    @Order(11)
    @DisplayName("Test weryfikacji atMost")
    void testAtMostWywolania() {
        // Jeśli: Mock modelu
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");

        // Gdy: Dodajemy 2 filmy
        adminController.dodajFilm("F001;Film1;Opis;100;Gatunek;20.0");
        adminController.dodajFilm("F002;Film2;Opis;110;Gatunek;25.0");

        // Wtedy: Weryfikacja atMost
        // Ref. z instrukcji: "atMost()"
        verify(mockModel, atMost(5)).dodajFilm(anyString());
    }

    // ========== TEST ARGUMENT CAPTOR ==========

    @Test
    @Order(12)
    @DisplayName("Test przechwytywania argumentów przekazanych do modelu")
    void testPrzechwytywanieDanych() {
        // Jeśli: Mock modelu
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");

        // Gdy: Wywołujemy z konkretnymi danymi
        String daneFilmu = "FTEST;CaptorTest;Opis testowy;99;TestGatunek;19.99";
        adminController.dodajFilm(daneFilmu);

        // Wtedy: Weryfikujemy przekazane dane
        ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
        verify(mockModel).dodajFilm(captor.capture());

        // Dane przekazane przez strategię powinny zawierać elementy oryginalne
        String captured = captor.getValue();
        assertNotNull(captured);
    }
}

\end{lstlisting}

\newpage

\subsubsection{controller.TestDodanieNowegoFilmuMock}
Plik: \texttt{src/test/java/controller/TestDodanieNowegoFilmuMock.java}

\begin{lstlisting}
package controller;

import model.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testy jednostkowe dla klasy DodanieNowegoFilmu - strategia dodawania filmu.
 * Testuje metodę DodanieNowegoFilmu.edytujOferte() z symulacją zależności
 * (IModel).
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Warstwa: Kontroli (controller)
 * Zadanie: 2 (testy z mockowaniem)
 * 
 * Ref. z instrukcji: "Testy klas modelujących elementarne usługi biznesowe"
 */
@DisplayName("Testy klasy DodanieNowegoFilmu - strategia z mockowaniem")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
@Tag("kontroler")
@Tag("dodawanie")
@Tag("mock")
class TestDodanieNowegoFilmuMock {

    /**
     * Mock obiektu Model - symulacja warstwy modelu.
     * Ref. z instrukcji: "adnotacja @Mock"
     */
    @Mock
    private IModel mockModel;

    /**
     * Testowana strategia.
     */
    private DodanieNowegoFilmu strategia;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów DodanieNowegoFilmu z mockowaniem");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Utworzenie strategii z mockowanym modelem
        strategia = new DodanieNowegoFilmu(mockModel);
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście
        reset(mockModel);
        strategia = null;
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów DodanieNowegoFilmu z mockowaniem");
    }

    // ========== TESTY DELEGACJI ==========

    @Test
    @Order(1)
    @DisplayName("Test że strategia deleguje do Model.dodajFilm()")
    void testDelegacjaDoModelu() {
        // Jeśli: Mock Model zwraca sukces
        // Ref. z instrukcji: "when().thenReturn()"
        String daneFilmu = "F001;Matrix;Cyberpunk;136;SciFi;28.5";
        when(mockModel.dodajFilm(daneFilmu)).thenReturn("Film dodany pomyslnie. ID: F001");

        // Gdy: Wywołujemy edytujOferte
        String wynik = strategia.edytujOferte(daneFilmu);

        // Wtedy: Model.dodajFilm powinien być wywołany raz
        assertNotNull(wynik);
        assertTrue(wynik.contains("pomyslnie"));

        // Ref. z instrukcji: "verify(), times()"
        verify(mockModel, times(1)).dodajFilm(daneFilmu);
    }

    @Test
    @Order(2)
    @DisplayName("Test że dane są przekazywane bez modyfikacji")
    void testPrzekazywanieDanychBezModyfikacji() {
        // Jeśli: Dane filmu
        String daneFilmu = "F001;Original;Description;100;Genre;20.0";
        when(mockModel.dodajFilm(daneFilmu)).thenReturn("OK");

        // Gdy: Wywołujemy strategię
        strategia.edytujOferte(daneFilmu);

        // Wtedy: Model powinien otrzymać dokładnie te same dane
        verify(mockModel).dodajFilm(eq(daneFilmu));
    }

    @Test
    @Order(3)
    @DisplayName("Test że wynik z modelu jest zwracany")
    void testZwracanieWyniku() {
        // Jeśli: Model zwraca określony wynik
        String oczekiwanyWynik = "Film dodany pomyslnie. ID: F002";
        when(mockModel.dodajFilm(anyString())).thenReturn(oczekiwanyWynik);

        // Gdy: Wywołujemy strategię
        String wynik = strategia.edytujOferte("F002;Film;Opis;120;Gatunek;25.0");

        // Wtedy: Wynik powinien być dokładnie taki jak z modelu
        assertEquals(oczekiwanyWynik, wynik);
    }

    // ========== TESTY Z WYJĄTKAMI ==========

    @Test
    @Order(4)
    @DisplayName("Test obsługi wyjątku z modelu")
    void testWyjatekZModelu() {
        // Jeśli: Model rzuca wyjątek
        // Ref. z instrukcji: "when().thenThrow()"
        when(mockModel.dodajFilm(anyString()))
                .thenThrow(new RuntimeException("Błąd dodawania filmu"));

        // Gdy/Wtedy: Strategia powinna propagować wyjątek
        assertThrows(RuntimeException.class,
                () -> strategia.edytujOferte("FE;Error;Opis;100;Gatunek;20.0"));
    }

    // ========== TESTY KOLEJNOŚCI - InOrder ==========

    @Test
    @Order(5)
    @DisplayName("Test kolejności wywołań")
    void testKolejnoscWywolan() {
        // Jeśli: InOrder dla weryfikacji
        // Ref. z instrukcji: "klasa InOrder w Mockito"
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");
        InOrder inOrder = inOrder(mockModel);

        // Gdy: Wywołujemy strategię
        strategia.edytujOferte("F001;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Model.dodajFilm powinien być jedynym wywołaniem
        inOrder.verify(mockModel).dodajFilm(anyString());
    }

    // ========== TESTY WERYFIKACJI ==========

    @Test
    @Order(6)
    @DisplayName("Test że inne metody modelu nie są wywoływane")
    void testNieWywolywanieInnychMetod() {
        // Jeśli: Mock
        when(mockModel.dodajFilm(anyString())).thenReturn("OK");

        // Gdy: Wywołujemy strategię
        strategia.edytujOferte("F001;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Tylko dodajFilm powinien być wywołany
        // Ref. z instrukcji: "never()"
        verify(mockModel, never()).edytujFilm(anyString(), anyString());
        verify(mockModel, never()).usunFilm(anyString());
    }

    // ========== TESTY PARAMETRYZOWANE ==========

    @ParameterizedTest
    @Order(7)
    @DisplayName("Test strategii z różnymi filmami - @CsvSource")
    @CsvSource({
            "F001, Matrix, SciFi, 136, SciFi, 28.0",
            "F002, Avatar, Fantasy, 162, SciFi, 35.0",
            "F003, Titanic, Romans, 195, Dramat, 25.0"
    })
    void testStrategiaParametryzowana(String id, String tytul, String opis,
            int czas, String gatunek, double cena) {
        // Jeśli: Mock zwraca sukces
        String expectedResult = "Film dodany pomyslnie. ID: " + id;
        String daneFilmu = id + ";" + tytul + ";" + opis + ";" + czas + ";" + gatunek + ";" + cena;
        when(mockModel.dodajFilm(daneFilmu)).thenReturn(expectedResult);

        // Gdy: Wywołujemy strategię
        String wynik = strategia.edytujOferte(daneFilmu);

        // Wtedy: Wynik powinien zawierać ID
        assertTrue(wynik.contains(id));
        verify(mockModel).dodajFilm(daneFilmu);
    }

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test strategii z różnymi komunikatami - @ValueSource")
    @ValueSource(strings = { "OK", "Sukces", "Film dodany" })
    void testRozneKomunikaty(String komunikat) {
        // Jeśli: Model zwraca różne komunikaty
        when(mockModel.dodajFilm(anyString())).thenReturn(komunikat);

        // Gdy: Wywołujemy strategię
        String wynik = strategia.edytujOferte("FX;Film;Opis;100;Gatunek;20.0");

        // Wtedy: Komunikat powinien być przekazany
        assertEquals(komunikat, wynik);
    }

    // ========== TESTY WIELOKROTNYCH WYWOŁAŃ ==========

    @Test
    @Order(9)
    @DisplayName("Test wielokrotnego użycia strategii")
    void testWielokrotneUzycie() {
        // Jeśli: Mock zwraca różne wyniki
        when(mockModel.dodajFilm(anyString()))
                .thenReturn("ID: F001")
                .thenReturn("ID: F002");

        // Gdy: Używamy strategii wielokrotnie
        String wynik1 = strategia.edytujOferte("F001;Film1;Opis;100;Gatunek;20.0");
        String wynik2 = strategia.edytujOferte("F002;Film2;Opis;110;Gatunek;25.0");

        // Wtedy: Każdy wynik powinien być inny
        assertNotEquals(wynik1, wynik2);

        // Ref. z instrukcji: "times(), atLeast()"
        verify(mockModel, times(2)).dodajFilm(anyString());
        verify(mockModel, atLeast(2)).dodajFilm(anyString());
        verify(mockModel, atMost(5)).dodajFilm(anyString());
    }
}

\end{lstlisting}

\newpage

\subsection{Przypadek użycia: Przeglądanie repertuaru}

W tym zadaniu testujemy klasy z symulacją zależności (z mockowaniem Mockito).

\subsubsection{model.TestModelPobierzRepertuarMock}
Plik: \texttt{src/test/java/model/TestModelPobierzRepertuarMock.java}

\begin{lstlisting}
package model;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testy jednostkowe dla klasy Model - pobieranie repertuaru z mockowaniem.
 * Testuje metodę Model.pobierzRepertuar() z symulacją zależności (IDAO).
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Encja (model)
 * Zadanie: 2 (testy z mockowaniem)
 * 
 * Ref. z instrukcji: "Symulować należy te fragmenty kodu (obiekty, operacje),
 * od których zależy testowana operacja"
 */
@DisplayName("Testy klasy Model - pobieranie repertuaru z mockowaniem")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
@Tag("encja")
@Tag("repertuar")
@Tag("mock")
class TestModelPobierzRepertuarMock {

    /**
     * Mock obiektu DAO - symulacja warstwy dostępu do danych.
     * Ref. z instrukcji: "operacja mock() lub adnotacja @Mock"
     */
    @Mock
    private IDAO mockDao;

    /**
     * Mock obiektu Oferta (wymagany przez konstruktor Model).
     */
    @Mock
    private Oferta mockOferta;

    /**
     * Testowany obiekt Model z wstrzykniętymi symulacjami.
     * Ref. z instrukcji: "adnotacja @InjectMocks w Mockito"
     */
    @InjectMocks
    private Model model;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów Model z mockowaniem - pobieranie repertuaru");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Inicjalizacja mocków - wykonywana automatycznie przez
        // @ExtendWith(MockitoExtension.class)
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście - resetowanie mocków
        reset(mockDao, mockOferta);
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów Model z mockowaniem - pobieranie repertuaru");
    }

    // ========== TESTY Z WHEN().THENRETURN() ==========

    @Test
    @Order(1)
    @DisplayName("Test pobierania repertuaru z seansami - sukces")
    void testPobierzRepertuarZSeansami() {
        // Jeśli: Mock DAO zwraca seanse dla filmu
        // Ref. z instrukcji: "when().thenReturn() w Mockito"
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1", "S2" });
        when(mockDao.znajdzSeans("S1")).thenReturn("F1;2024-12-20 18:00;Sala1;100");
        when(mockDao.znajdzSeans("S2")).thenReturn("F1;2024-12-20 21:00;Sala2;80");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Weryfikujemy wynik i użycie mocka
        assertNotNull(repertuar, "Repertuar nie powinien być null");
        assertTrue(repertuar.contains("Repertuar"), "Repertuar powinien zawierać nagłówek");
        assertTrue(repertuar.contains("Seans"), "Repertuar powinien zawierać seanse");

        // Ref. z instrukcji: "verify(), times()"
        verify(mockDao, times(1)).znajdzSeansyFilmu("F1");
        verify(mockDao, times(2)).znajdzSeans(anyString());
    }

    @Test
    @Order(2)
    @DisplayName("Test pobierania repertuaru bez seansów")
    void testPobierzRepertuarBezSeansow() {
        // Jeśli: Mock DAO zwraca pustą tablicę
        when(mockDao.znajdzSeansyFilmu("F99")).thenReturn(new String[] {});

        // Gdy: Pobieramy repertuar dla filmu bez seansów
        String repertuar = model.pobierzRepertuar("F99");

        // Wtedy: Powinien być komunikat o braku seansów
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"),
                "Repertuar powinien zawierać komunikat o braku seansów");

        // znajdzSeans nie powinien być wywołany
        // Ref. z instrukcji: "never()"
        verify(mockDao, never()).znajdzSeans(anyString());
    }

    @Test
    @Order(3)
    @DisplayName("Test pobierania repertuaru gdy znajdzSeansyFilmu zwraca null")
    void testPobierzRepertuarZwracaNull() {
        // Jeśli: Mock DAO zwraca null
        when(mockDao.znajdzSeansyFilmu("FNULL")).thenReturn(null);

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("FNULL");

        // Wtedy: Powinien być komunikat o braku seansów (nie wyjątek)
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"));
        verify(mockDao, never()).znajdzSeans(anyString());
    }

    @Test
    @Order(4)
    @DisplayName("Test pobierania repertuaru gdy seans nie istnieje w bazie")
    void testPobierzRepertuarSeansNieIstnieje() {
        // Jeśli: Mock DAO zwraca ID seansu, ale seans nie istnieje
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S999" });
        when(mockDao.znajdzSeans("S999")).thenReturn(null);

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar("F1");

        // Wtedy: Nie powinno być błędu, ale seans nie będzie w repertuarze
        assertNotNull(repertuar);
        verify(mockDao).znajdzSeans("S999");
    }

    // ========== TESTY KOLEJNOŚCI WYWOŁAŃ - InOrder ==========

    @Test
    @Order(5)
    @DisplayName("Test kolejności wywołań: najpierw znajdzSeansyFilmu, potem znajdzSeans")
    void testKolejnoscWywolanDAO() {
        // Jeśli: Określamy kolejność wywołań
        // Ref. z instrukcji: "klasa InOrder w Mockito"
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1" });
        when(mockDao.znajdzSeans("S1")).thenReturn("F1;2024-12-20 18:00;Sala1;100");
        InOrder inOrder = inOrder(mockDao);

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F1");

        // Wtedy: Najpierw szukamy seansów filmu, potem szczegóły seansu
        inOrder.verify(mockDao).znajdzSeansyFilmu("F1");
        inOrder.verify(mockDao).znajdzSeans("S1");
    }

    @Test
    @Order(6)
    @DisplayName("Test kolejności wywołań dla wielu seansów")
    void testKolejnoscWywolanWieleSeansow() {
        // Jeśli: Film ma 3 seanse
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1", "S2", "S3" });
        when(mockDao.znajdzSeans(anyString())).thenReturn("F1;2024-12-20 18:00;Sala1;100");
        InOrder inOrder = inOrder(mockDao);

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F1");

        // Wtedy: Najpierw znajdzSeansyFilmu, potem znajdzSeans dla każdego
        inOrder.verify(mockDao).znajdzSeansyFilmu("F1");
        inOrder.verify(mockDao).znajdzSeans("S1");
        inOrder.verify(mockDao).znajdzSeans("S2");
        inOrder.verify(mockDao).znajdzSeans("S3");
    }

    // ========== TESTY WERYFIKACJI LICZBY WYWOŁAŃ ==========

    @Test
    @Order(7)
    @DisplayName("Test że znajdzSeans jest wywoływane dla każdego ID seansu")
    void testZnajdzSeansWywolywaneDlaKazdego() {
        // Jeśli: Mock DAO zwraca 4 seanse
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1", "S2", "S3", "S4" });
        when(mockDao.znajdzSeans(anyString())).thenReturn("dane seansu");

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F1");

        // Wtedy: znajdzSeans powinno być wywołane 4 razy
        // Ref. z instrukcji: "times(), atLeast()"
        verify(mockDao, times(4)).znajdzSeans(anyString());
        verify(mockDao, atLeast(4)).znajdzSeans(anyString());
        verify(mockDao, atMost(4)).znajdzSeans(anyString());
    }

    @Test
    @Order(8)
    @DisplayName("Test że znajdzSeansyFilmu jest wywoływane dokładnie raz")
    void testZnajdzSeansyFilmuJednorazowo() {
        // Jeśli: Mock DAO
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1" });
        when(mockDao.znajdzSeans("S1")).thenReturn("dane");

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F1");

        // Wtedy: znajdzSeansyFilmu powinno być wywołane dokładnie raz
        verify(mockDao, times(1)).znajdzSeansyFilmu("F1");
        verify(mockDao, atMostOnce()).znajdzSeansyFilmu(anyString());
    }

    // ========== TESTY Z WHEN().THENTHROW() ==========

    @Test
    @Order(9)
    @DisplayName("Test obsługi wyjątku z DAO.znajdzSeansyFilmu")
    void testWyjatekZZnajdzSeansyFilmu() {
        // Jeśli: Mock DAO rzuca wyjątek
        // Ref. z instrukcji: "when().thenThrow() w Mockito"
        when(mockDao.znajdzSeansyFilmu("FERROR"))
                .thenThrow(new RuntimeException("Błąd bazy danych"));

        // Gdy/Wtedy: Operacja powinna propagować wyjątek
        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> model.pobierzRepertuar("FERROR"),
                "Powinien wystąpić RuntimeException");

        assertTrue(exception.getMessage().contains("Błąd bazy danych"));
    }

    @Test
    @Order(10)
    @DisplayName("Test obsługi wyjątku z DAO.znajdzSeans")
    void testWyjatekZZnajdzSeans() {
        // Jeśli: Mock DAO rzuca wyjątek przy znajdzSeans
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1" });
        when(mockDao.znajdzSeans("S1"))
                .thenThrow(new RuntimeException("Błąd odczytu seansu"));

        // Gdy/Wtedy: Wyjątek powinien być propagowany
        assertThrows(RuntimeException.class,
                () -> model.pobierzRepertuar("F1"));
    }

    // ========== TESTY WERYFIKACJI ARGUMENTÓW ==========

    @Test
    @Order(11)
    @DisplayName("Test że poprawne ID filmu jest przekazywane do DAO")
    void testPoprawneIdFilmuPrzekazywane() {
        // Jeśli: Mock DAO
        when(mockDao.znajdzSeansyFilmu(anyString())).thenReturn(new String[] {});

        // Gdy: Pobieramy repertuar z określonym ID
        model.pobierzRepertuar("FILM_TEST_123");

        // Wtedy: DAO powinno otrzymać dokładnie to ID
        verify(mockDao).znajdzSeansyFilmu(eq("FILM_TEST_123"));
    }

    @Test
    @Order(12)
    @DisplayName("Test przechwytywania argumentów przekazanych do DAO")
    void testPrzechwytywanieDanych() {
        // Jeśli: Mock DAO
        when(mockDao.znajdzSeansyFilmu(anyString())).thenReturn(new String[] { "S1" });
        when(mockDao.znajdzSeans(anyString())).thenReturn("dane");

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F_CAPTOR");

        // Wtedy: Weryfikujemy przekazane ID
        ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
        verify(mockDao).znajdzSeansyFilmu(captor.capture());

        assertEquals("F_CAPTOR", captor.getValue(),
                "Przekazane ID powinno być F_CAPTOR");
    }

    // ========== TESTY PARAMETRYZOWANE ==========

    @ParameterizedTest
    @Order(13)
    @DisplayName("Test pobierania repertuaru dla różnych filmów - @CsvSource")
    @CsvSource({
            "F1, 2, 2024-12-20 18:00",
            "F2, 1, 2024-12-21 19:00",
            "F3, 3, 2024-12-22 20:00"
    })
    void testPobierzRepertuarParametryzowany(String idFilmu, int liczbaSeansow, String data) {
        // Jeśli: Mock DAO zwraca określoną liczbę seansów
        String[] seansyIds = new String[liczbaSeansow];
        for (int i = 0; i < liczbaSeansow; i++) {
            seansyIds[i] = "S" + (i + 1);
        }
        when(mockDao.znajdzSeansyFilmu(idFilmu)).thenReturn(seansyIds);
        when(mockDao.znajdzSeans(anyString())).thenReturn(idFilmu + ";" + data + ";Sala1;100");

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar(idFilmu);

        // Wtedy: Weryfikujemy wynik
        assertNotNull(repertuar);
        assertTrue(repertuar.contains(idFilmu));
        verify(mockDao, times(liczbaSeansow)).znajdzSeans(anyString());
    }

    @ParameterizedTest
    @Order(14)
    @DisplayName("Test pobierania repertuaru dla różnych ID filmów - @ValueSource")
    @ValueSource(strings = { "F1", "F10", "FILM_2024", "XYZ123" })
    void testPobierzRepertuarRozneIdFilmow(String idFilmu) {
        // Jeśli: Mock DAO zwraca pusty wynik
        when(mockDao.znajdzSeansyFilmu(idFilmu)).thenReturn(new String[] {});

        // Gdy: Pobieramy repertuar
        String repertuar = model.pobierzRepertuar(idFilmu);

        // Wtedy: Powinien być komunikat o braku seansów z ID filmu
        assertNotNull(repertuar);
        assertTrue(repertuar.contains("Brak seansow"));
        assertTrue(repertuar.contains(idFilmu));
        verify(mockDao).znajdzSeansyFilmu(idFilmu);
    }

    // ========== TESTY WIELOKROTNYCH WYWOŁAŃ ==========

    @Test
    @Order(15)
    @DisplayName("Test wielokrotnego pobierania repertuaru")
    void testWielokrotnePobieranieRepertuaru() {
        // Jeśli: Mock DAO zwraca różne wyniki
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] { "S1" });
        when(mockDao.znajdzSeansyFilmu("F2")).thenReturn(new String[] { "S2", "S3" });
        when(mockDao.znajdzSeans(anyString())).thenReturn("dane seansu");

        // Gdy: Pobieramy repertuar dla różnych filmów
        String repertuarF1 = model.pobierzRepertuar("F1");
        String repertuarF2 = model.pobierzRepertuar("F2");

        // Wtedy: Każde wywołanie powinno użyć odpowiedniego ID
        verify(mockDao).znajdzSeansyFilmu("F1");
        verify(mockDao).znajdzSeansyFilmu("F2");
        verify(mockDao, times(3)).znajdzSeans(anyString()); // 1 + 2 = 3
    }

    @Test
    @Order(16)
    @DisplayName("Test że inne metody DAO nie są wywoływane")
    void testNieWywolywanieInnychMetod() {
        // Jeśli: Mock DAO
        when(mockDao.znajdzSeansyFilmu("F1")).thenReturn(new String[] {});

        // Gdy: Pobieramy repertuar
        model.pobierzRepertuar("F1");

        // Wtedy: Inne metody nie powinny być wywołane
        // Ref. z instrukcji: "never()"
        verify(mockDao, never()).dodajSeans(anyString());
        verify(mockDao, never()).usunSeans(anyString());
        verify(mockDao, never()).dodajFilm(anyString());
    }
}

\end{lstlisting}

\newpage

\subsubsection{controller.TestClientControllerPrzegladanieRepertuaruMock}
Plik: \texttt{src/test/java/controller/TestClientControllerPrzegladanieRepertuaruMock.java}

\begin{lstlisting}
package controller;

import model.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Testy jednostkowe dla klasy ClientController - przeglądanie repertuaru z
 * mockowaniem.
 * Testuje metodę ClientController.przegladajRepertuar() z symulacją zależności
 * (IModel).
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Warstwa: Kontroli (controller)
 * Zadanie: 2 (testy z mockowaniem)
 * 
 * Ref. z instrukcji: "Testy klas modelujących elementarne usługi biznesowe
 * w warstwie kontroli"
 */
@DisplayName("Testy klasy ClientController - przeglądanie repertuaru z mockowaniem")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@ExtendWith(MockitoExtension.class)
@Tag("kontroler")
@Tag("repertuar")
@Tag("mock")
class TestClientControllerPrzegladanieRepertuaruMock {

    /**
     * Mock obiektu Model - symulacja warstwy modelu.
     * Ref. z instrukcji: "adnotacja @Mock"
     */
    @Mock
    private IModel mockModel;

    /**
     * Testowany kontroler z wstrzykniętą symulacją modelu.
     * Ref. z instrukcji: "adnotacja @InjectMocks"
     */
    @InjectMocks
    private ClientController clientController;

    @BeforeAll
    static void setUpBeforeClass() {
        // Przygotowanie przed wszystkimi testami
        System.out.println("Rozpoczęcie testów ClientController z mockowaniem - przeglądanie repertuaru");
    }

    @BeforeEach
    void setUp() {
        // Jeśli: Inicjalizacja mocków - wykonywana automatycznie przez
        // @ExtendWith(MockitoExtension.class)
    }

    @AfterEach
    void tearDown() {
        // Sprzątanie po każdym teście - resetowanie mocków
        reset(mockModel);
    }

    @AfterAll
    static void tearDownAfterClass() {
        // Sprzątanie po wszystkich testach
        System.out.println("Zakończenie testów ClientController z mockowaniem - przeglądanie repertuaru");
    }

    // ========== TESTY DELEGACJI DO MODELU ==========

    @Test
    @Order(1)
    @DisplayName("Test że ClientController deleguje do Model.pobierzRepertuar()")
    void testDelegacjaDoModelu() {
        // Jeśli: Mock Model zwraca repertuar
        // Ref. z instrukcji: "when().thenReturn()"
        String oczekiwanyRepertuar = "Repertuar dla filmu F1:\n  - Seans: dane";
        when(mockModel.pobierzRepertuar("F1")).thenReturn(oczekiwanyRepertuar);

        // Gdy: Wywołujemy przegladajRepertuar przez kontroler
        String wynik = clientController.przegladajRepertuar("F1");

        // Wtedy: Model powinien być wywołany
        assertNotNull(wynik);
        assertEquals(oczekiwanyRepertuar, wynik);

        // Ref. z instrukcji: "verify(), times()"
        verify(mockModel, times(1)).pobierzRepertuar("F1");
    }

    @Test
    @Order(2)
    @DisplayName("Test że wynik z modelu jest zwracany bez modyfikacji")
    void testZwracanieWynikuBezModyfikacji() {
        // Jeśli: Model zwraca określony repertuar
        String repertuarZModelu = "Repertuar testowy:\n  - Seans 1\n  - Seans 2";
        when(mockModel.pobierzRepertuar("F1")).thenReturn(repertuarZModelu);

        // Gdy: Wywołujemy przez kontroler
        String wynik = clientController.przegladajRepertuar("F1");

        // Wtedy: Wynik powinien być identyczny
        assertEquals(repertuarZModelu, wynik,
                "Wynik powinien być identyczny z tym z modelu");
    }

    @Test
    @Order(3)
    @DisplayName("Test że kryteria są przekazywane do modelu bez modyfikacji")
    void testPrzekazywanieDanych() {
        // Jeśli: Mock modelu
        when(mockModel.pobierzRepertuar(anyString())).thenReturn("repertuar");

        // Gdy: Wywołujemy z konkretnymi kryteriami
        clientController.przegladajRepertuar("FILM_KRYTERIA_123");

        // Wtedy: Kryteria powinny być przekazane bez zmian
        verify(mockModel).pobierzRepertuar(eq("FILM_KRYTERIA_123"));
    }

    // ========== TESTY OBSŁUGI BŁĘDÓW ==========

    @Test
    @Order(4)
    @DisplayName("Test obsługi wyjątku z modelu")
    void testWyjatekZModelu() {
        // Jeśli: Model rzuca wyjątek
        // Ref. z instrukcji: "when().thenThrow()"
        when(mockModel.pobierzRepertuar("FERROR"))
                .thenThrow(new RuntimeException("Błąd w modelu"));

        // Gdy/Wtedy: Kontroler powinien propagować wyjątek
        RuntimeException ex = assertThrows(RuntimeException.class,
                () -> clientController.przegladajRepertuar("FERROR"));

        assertTrue(ex.getMessage().contains("Błąd w modelu"));
    }

    @Test
    @Order(5)
    @DisplayName("Test że wyjątek nie powoduje wielokrotnych wywołań")
    void testWyjatekNiePowodujePonownegoWywolania() {
        // Jeśli: Model rzuca wyjątek
        when(mockModel.pobierzRepertuar(anyString()))
                .thenThrow(new RuntimeException("Error"));

        // Gdy: Próba pobrania repertuaru
        try {
            clientController.przegladajRepertuar("FX");
        } catch (RuntimeException e) {
            // Oczekiwany wyjątek
        }

        // Wtedy: Model powinien być wywołany tylko raz
        // Ref. z instrukcji: "atMostOnce()"
        verify(mockModel, atMostOnce()).pobierzRepertuar(anyString());
    }

    // ========== TESTY KOLEJNOŚCI - InOrder ==========

    @Test
    @Order(6)
    @DisplayName("Test kolejności wywołań z InOrder")
    void testKolejnoscWywolan() {
        // Jeśli: Mock modelu
        // Ref. z instrukcji: "klasa InOrder w Mockito"
        when(mockModel.pobierzRepertuar(anyString())).thenReturn("repertuar");
        InOrder inOrder = inOrder(mockModel);

        // Gdy: Wywołujemy przegladajRepertuar
        clientController.przegladajRepertuar("F1");

        // Wtedy: Model.pobierzRepertuar powinien być wywołany
        inOrder.verify(mockModel).pobierzRepertuar("F1");
    }

    // ========== TESTY WERYFIKACJI NEVER ==========

    @Test
    @Order(7)
    @DisplayName("Test że inne metody modelu nie są wywoływane")
    void testNieWywolywanieInnychMetod() {
        // Jeśli: Mock modelu
        when(mockModel.pobierzRepertuar(anyString())).thenReturn("repertuar");

        // Gdy: Wywołujemy przegladajRepertuar
        clientController.przegladajRepertuar("F1");

        // Wtedy: Inne metody nie powinny być wywołane
        // Ref. z instrukcji: "never()"
        verify(mockModel, never()).dodajFilm(anyString());
        verify(mockModel, never()).usunFilm(anyString());
        verify(mockModel, never()).zarezerwujMiejsce(anyString());
        verify(mockModel, never()).dodajSeans(anyString());
    }

    // ========== TESTY PARAMETRYZOWANE ==========

    @ParameterizedTest
    @Order(8)
    @DisplayName("Test przeglądania repertuaru różnych filmów - @CsvSource")
    @CsvSource({
            "F1, Repertuar dla F1",
            "F2, Repertuar dla F2",
            "F3, Repertuar dla F3"
    })
    void testPrzegladajRepertuarParametryzowany(String idFilmu, String oczekiwanyRepertuar) {
        // Jeśli: Mock zwraca odpowiedni repertuar
        when(mockModel.pobierzRepertuar(idFilmu)).thenReturn(oczekiwanyRepertuar);

        // Gdy: Wywołujemy z parametrami
        String wynik = clientController.przegladajRepertuar(idFilmu);

        // Wtedy: Wynik powinien odpowiadać oczekiwanemu
        assertEquals(oczekiwanyRepertuar, wynik);
        verify(mockModel).pobierzRepertuar(idFilmu);
    }

    @ParameterizedTest
    @Order(9)
    @DisplayName("Test przeglądania repertuaru z różnymi komunikatami - @ValueSource")
    @ValueSource(strings = {
            "Repertuar dla filmu F1:\n  - Seans: 18:00",
            "Repertuar dla filmu F2:\n  - Seans: 20:00\n  - Seans: 22:00",
            "Brak seansow dla filmu F99"
    })
    void testRozneKomunikatyZwrotne(String komunikatZModelu) {
        // Jeśli: Model zwraca różne komunikaty
        when(mockModel.pobierzRepertuar(anyString())).thenReturn(komunikatZModelu);

        // Gdy: Wywołujemy kontroler
        String wynik = clientController.przegladajRepertuar("FX");

        // Wtedy: Komunikat powinien być przekazany bez zmian
        assertEquals(komunikatZModelu, wynik);
    }

    // ========== TESTY WIELOKROTNYCH WYWOŁAŃ ==========

    @Test
    @Order(10)
    @DisplayName("Test wielokrotnego przeglądania repertuaru")
    void testWielokrotnePrzegladanieRepertuaru() {
        // Jeśli: Model zwraca różne odpowiedzi
        when(mockModel.pobierzRepertuar("F1")).thenReturn("Repertuar F1");
        when(mockModel.pobierzRepertuar("F2")).thenReturn("Repertuar F2");
        when(mockModel.pobierzRepertuar("F3")).thenReturn("Repertuar F3");

        // Gdy: Przeglądamy 3 repertuary
        String wynik1 = clientController.przegladajRepertuar("F1");
        String wynik2 = clientController.przegladajRepertuar("F2");
        String wynik3 = clientController.przegladajRepertuar("F3");

        // Wtedy: Każdy wynik powinien być inny
        assertEquals("Repertuar F1", wynik1);
        assertEquals("Repertuar F2", wynik2);
        assertEquals("Repertuar F3", wynik3);

        // Ref. z instrukcji: "times(), atLeast()"
        verify(mockModel, times(3)).pobierzRepertuar(anyString());
        verify(mockModel, atLeast(3)).pobierzRepertuar(anyString());
    }

    @Test
    @Order(11)
    @DisplayName("Test wielokrotnego przeglądania tego samego repertuaru")
    void testWielokrotnePrzegladanieTegoSamego() {
        // Jeśli: Model zwraca ten sam wynik
        when(mockModel.pobierzRepertuar("F1")).thenReturn("Repertuar F1");

        // Gdy: Przeglądamy ten sam repertuar wielokrotnie
        String wynik1 = clientController.przegladajRepertuar("F1");
        String wynik2 = clientController.przegladajRepertuar("F1");
        String wynik3 = clientController.przegladajRepertuar("F1");

        // Wtedy: Wszystkie wyniki powinny być identyczne
        assertEquals(wynik1, wynik2);
        assertEquals(wynik2, wynik3);

        // Model powinien być wywołany 3 razy
        verify(mockModel, times(3)).pobierzRepertuar("F1");
    }

    @Test
    @Order(12)
    @DisplayName("Test weryfikacji atMost")
    void testAtMostWywolania() {
        // Jeśli: Mock modelu
        when(mockModel.pobierzRepertuar(anyString())).thenReturn("repertuar");

        // Gdy: Przeglądamy 2 repertuary
        clientController.przegladajRepertuar("F1");
        clientController.przegladajRepertuar("F2");

        // Wtedy: Weryfikacja atMost
        // Ref. z instrukcji: "atMost()"
        verify(mockModel, atMost(5)).pobierzRepertuar(anyString());
    }

    // ========== TEST ARGUMENT CAPTOR ==========

    @Test
    @Order(13)
    @DisplayName("Test przechwytywania argumentów przekazanych do modelu")
    void testPrzechwytywanieDanych() {
        // Jeśli: Mock modelu
        when(mockModel.pobierzRepertuar(anyString())).thenReturn("repertuar");

        // Gdy: Wywołujemy z konkretnymi kryteriami
        clientController.przegladajRepertuar("CAPTOR_TEST_FILM");

        // Wtedy: Weryfikujemy przekazane dane
        ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
        verify(mockModel).pobierzRepertuar(captor.capture());

        String przekazane = captor.getValue();
        assertEquals("CAPTOR_TEST_FILM", przekazane,
                "Przekazane kryteria powinny być identyczne");
    }

    // ========== TESTY EDGE CASES ==========

    @Test
    @Order(14)
    @DisplayName("Test przeglądania repertuaru z pustym ID")
    void testPrzegladajRepertuarPusteId() {
        // Jeśli: Model obsługuje puste ID
        when(mockModel.pobierzRepertuar("")).thenReturn("Brak seansow dla filmu: ");

        // Gdy: Wywołujemy z pustym ID
        String wynik = clientController.przegladajRepertuar("");

        // Wtedy: Powinniśmy otrzymać odpowiedni komunikat
        assertNotNull(wynik);
        verify(mockModel).pobierzRepertuar("");
    }

    @Test
    @Order(15)
    @DisplayName("Test gdy model zwraca null")
    void testModelZwracaNull() {
        // Jeśli: Model zwraca null
        when(mockModel.pobierzRepertuar("FNULL")).thenReturn(null);

        // Gdy: Wywołujemy kontroler
        String wynik = clientController.przegladajRepertuar("FNULL");

        // Wtedy: Wynik powinien być null (przekazany bez modyfikacji)
        assertNull(wynik, "Jeśli model zwraca null, kontroler powinien zwrócić null");
        verify(mockModel).pobierzRepertuar("FNULL");
    }

    @Test
    @Order(16)
    @DisplayName("Test że kontroler nie modyfikuje danych z modelu")
    void testNieModyfikujeDanych() {
        // Jeśli: Model zwraca konkretny tekst z wieloma liniami
        String oryginalnyRepertuar = "Repertuar dla filmu F1:\n" +
                "  - Seans: F1;2024-12-20 18:00;Sala1;100\n" +
                "  - Seans: F1;2024-12-20 21:00;Sala2;80\n";
        when(mockModel.pobierzRepertuar("F1")).thenReturn(oryginalnyRepertuar);

        // Gdy: Wywołujemy kontroler
        String wynik = clientController.przegladajRepertuar("F1");

        // Wtedy: Wynik powinien być identyczny co do znaku
        assertEquals(oryginalnyRepertuar, wynik,
                "Kontroler nie powinien modyfikować danych");
        assertEquals(oryginalnyRepertuar.length(), wynik.length(),
                "Długość tekstu powinna być identyczna");
    }
}

\end{lstlisting}

\newpage


\section{Zadanie 3: Zestawy testów (Test Suites)}

\subsection{Przypadek użycia: Dodanie filmu do oferty}

Zestawy testów pozwalają na grupowanie testów według różnych kryteriów.

\subsubsection{model.SuiteEncjiDodawanieFilmu}
Plik: \texttt{src/test/java/model/SuiteEncjiDodawanieFilmu.java}

\begin{lstlisting}
package model;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów warstwy encji (model) dla przypadku użycia "Dodanie filmu do
 * oferty".
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia wszystkie testy z pakietu model oznaczone tagiem
 * "dodawanie".
 * 
 * Ref. z instrukcji: "zestaw testów klas warstwy encji, czyli znajdujących się
 * w jej pakiecie"
 * 
 * Praktyczne zastosowanie: Weryfikacja poprawności wszystkich klas encji
 * zaangażowanych w proces dodawania filmu (Film, FabrykaFilmu, DAO, Model).
 */
@Suite
@SuiteDisplayName("Zestaw testów warstwy encji - Dodanie filmu do oferty")
@SelectPackages("model")
@IncludeTags("dodawanie")
public class SuiteEncjiDodawanieFilmu {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów:
     * - TestFilm.java - testy encji Film
     * - TestDAO.java - testy Data Access Object
     * - TestFabrykaStandardowegoFilmu.java - testy fabryki filmów
     * - TestModelDodawanieFilmu.java - testy Model.dodajFilm() bez mockowania
     * - TestModelDodawanieFilmuMock.java - testy Model.dodajFilm() z mockowaniem
     * 
     * Wszystkie powyższe klasy są oznaczone tagami @Tag("encja")
     * i @Tag("dodawanie")
     */
}

\end{lstlisting}

\newpage

\subsubsection{controller.SuiteKontroliDodawanieFilmu}
Plik: \texttt{src/test/java/controller/SuiteKontroliDodawanieFilmu.java}

\begin{lstlisting}
package controller;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów warstwy kontroli (controller) dla przypadku użycia "Dodanie
 * filmu do oferty".
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia wszystkie testy z pakietu controller oznaczone tagiem
 * "dodawanie".
 * 
 * Ref. z instrukcji: "zestaw testów klas warstwy kontroli, czyli znajdujących
 * się w jej pakiecie"
 * 
 * Praktyczne zastosowanie: Weryfikacja poprawności kontrolerów i strategii
 * zaangażowanych w proces dodawania filmu (AdminController,
 * EdytowanieOfertyKina, DodanieNowegoFilmu).
 */
@Suite
@SuiteDisplayName("Zestaw testów warstwy kontroli - Dodanie filmu do oferty")
@SelectPackages("controller")
@IncludeTags("dodawanie")
public class SuiteKontroliDodawanieFilmu {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów:
     * - TestAdminControllerDodawanieFilmu.java - testy kontrolera bez mockowania
     * - TestAdminControllerDodawanieFilmuMock.java - testy kontrolera z mockowaniem
     * - TestDodanieNowegoFilmuMock.java - testy strategii z mockowaniem
     * 
     * Wszystkie powyższe klasy są oznaczone tagami @Tag("kontroler")
     * i @Tag("dodawanie")
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuiteDodawanieFilmuBezMock}
Plik: \texttt{src/test/java/suites/SuiteDodawanieFilmuBezMock.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Dodanie filmu do oferty" BEZ mockowania.
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Zadanie: 3 (zestawy testów bazujące na tagach)
 * 
 * Ten zestaw uruchamia testy oznaczone tagiem "dodawanie", ale WYKLUCZA testy z
 * tagiem "mock".
 * 
 * Ref. z instrukcji: "przynajmniej 2 zestawy testów oznaczonych wybranymi
 * tagami
 * i nie oznaczonych innymi wybranymi tagami, które mają jakieś praktyczne
 * zastosowanie"
 * 
 * Praktyczne zastosowanie:
 * - Testy integracyjne bez mockowania - sprawdzają rzeczywistą współpracę
 * komponentów
 * - Szybka weryfikacja podstawowej funkcjonalności dodawania filmu
 * - Przydatne do testów regresji przed wdrożeniem
 * - Uruchamiane gdy chcemy sprawdzić pełny przepływ bez izolacji zależności
 */
@Suite
@SuiteDisplayName("Zestaw testów dodawania filmu - BEZ mockowania")
@SelectPackages({ "model", "controller" })
@IncludeTags("dodawanie")
@ExcludeTags("mock")
public class SuiteDodawanieFilmuBezMock {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów (bez mockowania):
     * 
     * Z pakietu model:
     * - TestFilm.java - testy encji Film
     * - TestDAO.java - testy Data Access Object
     * - TestFabrykaStandardowegoFilmu.java - testy fabryki filmów
     * - TestModelDodawanieFilmu.java - testy Model.dodajFilm() bez mockowania
     * 
     * Z pakietu controller:
     * - TestAdminControllerDodawanieFilmu.java - testy kontrolera bez mockowania
     * 
     * WYKLUCZONE (tag "mock"):
     * - TestModelDodawanieFilmuMock.java
     * - TestAdminControllerDodawanieFilmuMock.java
     * - TestDodanieNowegoFilmuMock.java
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuiteDodawanieFilmuMock}
Plik: \texttt{src/test/java/suites/SuiteDodawanieFilmuMock.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Dodanie filmu do oferty" TYLKO Z
 * mockowaniem.
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Zadanie: 3 (zestawy testów bazujące na tagach)
 * 
 * Ten zestaw uruchamia TYLKO testy oznaczone tagami "dodawanie" ORAZ "mock".
 * 
 * Ref. z instrukcji: "przynajmniej 2 zestawy testów oznaczonych wybranymi
 * tagami
 * i nie oznaczonych innymi wybranymi tagami, które mają jakieś praktyczne
 * zastosowanie"
 * 
 * Praktyczne zastosowanie:
 * - Szybkie testy jednostkowe z izolacją zależności
 * - Weryfikacja logiki biznesowej bez potrzeby rzeczywistych zależności
 * - Testy uruchamiane podczas CI/CD dla szybkiego feedbacku
 * - Przydatne gdy warstwa DAO lub inne zależności są niedostępne
 * - Testowanie obsługi błędów i edge cases (symulacja wyjątków)
 */
@Suite
@SuiteDisplayName("Zestaw testów dodawania filmu - TYLKO z mockowaniem")
@SelectPackages({ "model", "controller" })
@IncludeTags({ "dodawanie", "mock" })
public class SuiteDodawanieFilmuMock {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów (tylko z mockowaniem):
     * 
     * Z pakietu model:
     * - TestModelDodawanieFilmuMock.java - testy Model z mockowanym DAO
     * * Testuje: when/thenReturn, when/thenThrow, doNothing, doThrow
     * * Weryfikuje: verify, times, never, atLeast, atMost, InOrder
     * 
     * Z pakietu controller:
     * - TestAdminControllerDodawanieFilmuMock.java - testy kontrolera z mockowanym
     * IModel
     * - TestDodanieNowegoFilmuMock.java - testy strategii z mockowanym IModel
     * 
     * WYKLUCZONE (brak tagu "mock"):
     * - TestFilm.java
     * - TestDAO.java
     * - TestFabrykaStandardowegoFilmu.java
     * - TestModelDodawanieFilmu.java
     * - TestAdminControllerDodawanieFilmu.java
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuiteDodawanieFilmuWszystkie}
Plik: \texttt{src/test/java/suites/SuiteDodawanieFilmuWszystkie.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Dodanie filmu do oferty" - WSZYSTKIE
 * testy.
 * 
 * Przypadek użycia: Dodanie filmu do oferty
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia WSZYSTKIE testy związane z dodawaniem filmu,
 * używając tagu "dodawanie" do ich wyboru.
 * 
 * Ref. z instrukcji: "adnotacje @IncludeTags w JUnit6"
 * 
 * Praktyczne zastosowanie:
 * - Pełna weryfikacja przypadku użycia "Dodanie filmu do oferty"
 * - Kompletny zestaw testów do uruchomienia przed release'em
 * - Zawiera zarówno testy jednostkowe jak i testy z mockowaniem
 */
@Suite
@SuiteDisplayName("Zestaw WSZYSTKICH testów - Dodanie filmu do oferty")
@SelectPackages({ "model", "controller" })
@IncludeTags("dodawanie")
public class SuiteDodawanieFilmuWszystkie {
    // Klasa zestawu testów - testy są wybierane przez @IncludeTags

    /*
     * Ten zestaw zawiera WSZYSTKIE testy dla przypadku użycia
     * "Dodanie filmu do oferty":
     * 
     * ZADANIE 1 (bez mockowania) - oznaczone @Tag("dodawanie"):
     * - model.TestFilm - testy encji danych filmu
     * - model.TestDAO - testy warstwy dostępu do danych
     * - model.TestFabrykaStandardowegoFilmu - testy fabryki tworzenia filmów
     * - model.TestModelDodawanieFilmu - testy fasady Model
     * - controller.TestAdminControllerDodawanieFilmu - testy kontrolera admin
     * 
     * ZADANIE 2 (z mockowaniem) - oznaczone @Tag("dodawanie") i @Tag("mock"):
     * - model.TestModelDodawanieFilmuMock - testy Model z @Mock IDAO
     * - controller.TestAdminControllerDodawanieFilmuMock - testy z @Mock IModel
     * - controller.TestDodanieNowegoFilmuMock - testy strategii z @Mock IModel
     * 
     * Łącznie: 8 klas testowych, ~80+ testów
     */
}

\end{lstlisting}

\newpage

\subsection{Przypadek użycia: Przeglądanie repertuaru}

Zestawy testów pozwalają na grupowanie testów według różnych kryteriów.

\subsubsection{model.SuiteEncjiPrzegladanieRepertuaru}
Plik: \texttt{src/test/java/model/SuiteEncjiPrzegladanieRepertuaru.java}

\begin{lstlisting}
package model;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów warstwy encji (model) dla przypadku użycia "Przeglądanie
 * repertuaru".
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia wszystkie testy z pakietu model oznaczone tagiem
 * "repertuar".
 * 
 * Ref. z instrukcji: "zestaw testów klas warstwy encji, czyli znajdujących się
 * w jej pakiecie"
 * 
 * Praktyczne zastosowanie: Weryfikacja poprawności wszystkich klas encji
 * zaangażowanych w proces przeglądania repertuaru (Seans, DAO, Model).
 */
@Suite
@SuiteDisplayName("Zestaw testów warstwy encji - Przeglądanie repertuaru")
@SelectPackages("model")
@IncludeTags("repertuar")
public class SuiteEncjiPrzegladanieRepertuaru {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów:
     * - TestSeans.java - testy encji Seans
     * - TestDAOSeansy.java - testy operacji DAO związanych z seansami
     * - TestModelPobierzRepertuar.java - testy Model.pobierzRepertuar() bez
     * mockowania
     * - TestModelPobierzRepertuarMock.java - testy Model.pobierzRepertuar() z
     * mockowaniem
     * 
     * Wszystkie powyższe klasy są oznaczone tagami @Tag("encja")
     * i @Tag("repertuar")
     */
}

\end{lstlisting}

\newpage

\subsubsection{controller.SuiteKontroliPrzegladanieRepertuaru}
Plik: \texttt{src/test/java/controller/SuiteKontroliPrzegladanieRepertuaru.java}

\begin{lstlisting}
package controller;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów warstwy kontroli (controller) dla przypadku użycia
 * "Przeglądanie repertuaru".
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia wszystkie testy z pakietu controller oznaczone tagiem
 * "repertuar".
 * 
 * Ref. z instrukcji: "zestaw testów klas warstwy kontroli, czyli znajdujących
 * się w jej pakiecie"
 * 
 * Praktyczne zastosowanie: Weryfikacja poprawności kontrolerów klienckich
 * zaangażowanych w proces przeglądania repertuaru (ClientController).
 */
@Suite
@SuiteDisplayName("Zestaw testów warstwy kontroli - Przeglądanie repertuaru")
@SelectPackages("controller")
@IncludeTags("repertuar")
public class SuiteKontroliPrzegladanieRepertuaru {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów:
     * - TestClientControllerPrzegladanieRepertuaru.java - testy kontrolera bez
     * mockowania
     * - TestClientControllerPrzegladanieRepertuaruMock.java - testy kontrolera z
     * mockowaniem
     * 
     * Wszystkie powyższe klasy są oznaczone tagami @Tag("kontroler")
     * i @Tag("repertuar")
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuitePrzegladanieRepertuaruBezMock}
Plik: \texttt{src/test/java/suites/SuitePrzegladanieRepertuaruBezMock.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Przeglądanie repertuaru" BEZ mockowania.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Zadanie: 3 (zestawy testów bazujące na tagach)
 * 
 * Ten zestaw uruchamia testy oznaczone tagiem "repertuar", ale WYKLUCZA testy z
 * tagiem "mock".
 * 
 * Ref. z instrukcji: "przynajmniej 2 zestawy testów oznaczonych wybranymi
 * tagami
 * i nie oznaczonych innymi wybranymi tagami, które mają jakieś praktyczne
 * zastosowanie"
 * 
 * Praktyczne zastosowanie:
 * - Testy integracyjne bez mockowania - sprawdzają rzeczywistą współpracę
 * komponentów
 * - Szybka weryfikacja podstawowej funkcjonalności przeglądania repertuaru
 * - Przydatne do testów regresji przed wdrożeniem
 * - Uruchamiane gdy chcemy sprawdzić pełny przepływ bez izolacji zależności
 */
@Suite
@SuiteDisplayName("Zestaw testów przeglądania repertuaru - BEZ mockowania")
@SelectPackages({ "model", "controller" })
@IncludeTags("repertuar")
@ExcludeTags("mock")
public class SuitePrzegladanieRepertuaruBezMock {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów (bez mockowania):
     * 
     * Z pakietu model:
     * - TestSeans.java - testy encji Seans
     * - TestDAOSeansy.java - testy operacji DAO związanych z seansami
     * - TestModelPobierzRepertuar.java - testy Model.pobierzRepertuar() bez
     * mockowania
     * 
     * Z pakietu controller:
     * - TestClientControllerPrzegladanieRepertuaru.java - testy kontrolera bez
     * mockowania
     * 
     * WYKLUCZONE (tag "mock"):
     * - TestModelPobierzRepertuarMock.java
     * - TestClientControllerPrzegladanieRepertuaruMock.java
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuitePrzegladanieRepertuaruMock}
Plik: \texttt{src/test/java/suites/SuitePrzegladanieRepertuaruMock.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Przeglądanie repertuaru" TYLKO Z
 * mockowaniem.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Zadanie: 3 (zestawy testów bazujące na tagach)
 * 
 * Ten zestaw uruchamia TYLKO testy oznaczone tagami "repertuar" ORAZ "mock".
 * 
 * Ref. z instrukcji: "przynajmniej 2 zestawy testów oznaczonych wybranymi
 * tagami
 * i nie oznaczonych innymi wybranymi tagami, które mają jakieś praktyczne
 * zastosowanie"
 * 
 * Praktyczne zastosowanie:
 * - Szybkie testy jednostkowe z izolacją zależności
 * - Weryfikacja logiki biznesowej bez potrzeby rzeczywistych zależności
 * - Testy uruchamiane podczas CI/CD dla szybkiego feedbacku
 * - Przydatne gdy warstwa DAO lub inne zależności są niedostępne
 * - Testowanie obsługi błędów i edge cases (symulacja wyjątków)
 */
@Suite
@SuiteDisplayName("Zestaw testów przeglądania repertuaru - TYLKO z mockowaniem")
@SelectPackages({ "model", "controller" })
@IncludeTags({ "repertuar", "mock" })
public class SuitePrzegladanieRepertuaruMock {
    // Klasa zestawu testów - testy są wybierane automatycznie na podstawie
    // adnotacji

    /*
     * Ten zestaw zawiera następujące klasy testów (tylko z mockowaniem):
     * 
     * Z pakietu model:
     * - TestModelPobierzRepertuarMock.java - testy Model z mockowanym IDAO
     * * Testuje: when/thenReturn, when/thenThrow, InOrder, ArgumentCaptor
     * * Weryfikuje: verify, times, never, atLeast, atMost
     * 
     * Z pakietu controller:
     * - TestClientControllerPrzegladanieRepertuaruMock.java - testy z mockowanym
     * IModel
     * 
     * WYKLUCZONE (brak tagu "mock"):
     * - TestSeans.java
     * - TestDAOSeansy.java
     * - TestModelPobierzRepertuar.java
     * - TestClientControllerPrzegladanieRepertuaru.java
     */
}

\end{lstlisting}

\newpage

\subsubsection{suites.SuitePrzegladanieRepertuaruWszystkie}
Plik: \texttt{src/test/java/suites/SuitePrzegladanieRepertuaruWszystkie.java}

\begin{lstlisting}
package suites;

import org.junit.platform.suite.api.*;

/**
 * Zestaw testów dla przypadku użycia "Przeglądanie repertuaru" - WSZYSTKIE
 * testy.
 * 
 * Przypadek użycia: Przeglądanie repertuaru
 * Zadanie: 3 (zestawy testów)
 * 
 * Ten zestaw uruchamia WSZYSTKIE testy związane z przeglądaniem repertuaru,
 * używając tagu "repertuar" do ich wyboru.
 * 
 * Ref. z instrukcji: "adnotacje @IncludeTags w JUnit6"
 * 
 * Praktyczne zastosowanie:
 * - Pełna weryfikacja przypadku użycia "Przeglądanie repertuaru"
 * - Kompletny zestaw testów do uruchomienia przed release'em
 * - Zawiera zarówno testy jednostkowe jak i testy z mockowaniem
 */
@Suite
@SuiteDisplayName("Zestaw WSZYSTKICH testów - Przeglądanie repertuaru")
@SelectPackages({ "model", "controller" })
@IncludeTags("repertuar")
public class SuitePrzegladanieRepertuaruWszystkie {
    // Klasa zestawu testów - testy są wybierane przez @IncludeTags

    /*
     * Ten zestaw zawiera WSZYSTKIE testy dla przypadku użycia
     * "Przeglądanie repertuaru":
     * 
     * ZADANIE 1 (bez mockowania) - oznaczone @Tag("repertuar"):
     * - model.TestSeans - testy encji danych seansu
     * - model.TestDAOSeansy - testy warstwy dostępu do danych (operacje seansów)
     * - model.TestModelPobierzRepertuar - testy fasady Model
     * - controller.TestClientControllerPrzegladanieRepertuaru - testy kontrolera
     * klienta
     * 
     * ZADANIE 2 (z mockowaniem) - oznaczone @Tag("repertuar") i @Tag("mock"):
     * - model.TestModelPobierzRepertuarMock - testy Model z @Mock IDAO
     * - controller.TestClientControllerPrzegladanieRepertuaruMock - testy z @Mock
     * IModel
     * 
     * Łącznie: 6 klas testowych, ~90+ testów
     */
}

\end{lstlisting}

\newpage


\section{Podsumowanie}

Sprawozdanie zawiera pełny kod testów jednostkowych dla dwóch przypadków użycia:

\subsection{Przypadek użycia 1: Dodanie filmu do oferty}
\begin{itemize}
    \item \textbf{Zadanie 1}: Testy bez mockowania (5 klas testowych)
    \item \textbf{Zadanie 2}: Testy z mockowaniem Mockito (3 klasy testowe)  
    \item \textbf{Zadanie 3}: Zestawy testów (5 klas zestawów)
\end{itemize}

\subsection{Przypadek użycia 2: Przeglądanie repertuaru}
\begin{itemize}
    \item \textbf{Zadanie 1}: Testy bez mockowania (4 klasy testowe)
    \item \textbf{Zadanie 2}: Testy z mockowaniem Mockito (2 klasy testowe)  
    \item \textbf{Zadanie 3}: Zestawy testów (5 klas zestawów)
\end{itemize}

Łącznie utworzono 24 klasy testowe zawierających ponad 170 testów jednostkowych.

\end{document}
